<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: pcpp::Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00071.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00257.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::Packet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00157_source.html">Packet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1a6d4e157661ba7ec6f552c78c82d7fa">Packet</a> (size_t maxPacketLen=1)</td></tr>
<tr class="separator:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf7d18a51920fe87c54ae234941816"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab9bf7d18a51920fe87c54ae234941816">Packet</a> (<a class="el" href="a00094.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:ab9bf7d18a51920fe87c54ae234941816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072415e151c3f8b2e55df859160d4dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ac072415e151c3f8b2e55df859160d4dd">Packet</a> (<a class="el" href="a00094.html">RawPacket</a> *rawPacket, bool freeRawPacket)</td></tr>
<tr class="separator:ac072415e151c3f8b2e55df859160d4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a54ccf8336cf3c3f6a5ad58ad12f06656">~Packet</a> ()</td></tr>
<tr class="separator:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d603615d2f100eec547d51b4a6282e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a11d603615d2f100eec547d51b4a6282e">Packet</a> (const <a class="el" href="a00071.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a11d603615d2f100eec547d51b4a6282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af180628893e454e9d6e0f2f1ebb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00071.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a26af180628893e454e9d6e0f2f1ebb98">operator=</a> (const <a class="el" href="a00071.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a26af180628893e454e9d6e0f2f1ebb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7727ee05d4dc422ebe74c58ddd11cb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a7727ee05d4dc422ebe74c58ddd11cb22">getRawPacket</a> ()</td></tr>
<tr class="separator:a7727ee05d4dc422ebe74c58ddd11cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf994984d94f2ffacb367172cfad08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5ebf994984d94f2ffacb367172cfad08">setRawPacket</a> (<a class="el" href="a00094.html">RawPacket</a> *rawPacket, bool freeRawPacket)</td></tr>
<tr class="separator:a5ebf994984d94f2ffacb367172cfad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a88c7423642329409672f612990724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#af8a88c7423642329409672f612990724">getRawPacketReadOnly</a> () const </td></tr>
<tr class="separator:af8a88c7423642329409672f612990724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f98bcdd465eac96673752838826de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00061.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a02f98bcdd465eac96673752838826de4">getFirstLayer</a> ()</td></tr>
<tr class="separator:a02f98bcdd465eac96673752838826de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2dd7a761efe7393249ddc54bdd662b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00061.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a1c2dd7a761efe7393249ddc54bdd662b">getLastLayer</a> ()</td></tr>
<tr class="separator:a1c2dd7a761efe7393249ddc54bdd662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c12806f2b320cdddd83a2b3a1136eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer</a> (<a class="el" href="a00061.html">Layer</a> *newLayer)</td></tr>
<tr class="separator:af4c12806f2b320cdddd83a2b3a1136eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f9ea31fb1b7fa610db251405522f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer</a> (<a class="el" href="a00061.html">Layer</a> *prevLayer, <a class="el" href="a00061.html">Layer</a> *newLayer)</td></tr>
<tr class="separator:a2e2f9ea31fb1b7fa610db251405522f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab751fc35d7e7b8a86e3f1fdbd2c30685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab751fc35d7e7b8a86e3f1fdbd2c30685">removeLayer</a> (<a class="el" href="a00061.html">Layer</a> *layer)</td></tr>
<tr class="separator:ab751fc35d7e7b8a86e3f1fdbd2c30685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d0de95b49eb313e3184021234e5c5e"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:a78d0de95b49eb313e3184021234e5c5e"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00071.html#a78d0de95b49eb313e3184021234e5c5e">getLayerOfType</a> ()</td></tr>
<tr class="separator:a78d0de95b49eb313e3184021234e5c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d545bb4bc80e5d45858c373b20befa9"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:a1d545bb4bc80e5d45858c373b20befa9"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00071.html#a1d545bb4bc80e5d45858c373b20befa9">getNextLayerOfType</a> (<a class="el" href="a00061.html">Layer</a> *after)</td></tr>
<tr class="separator:a1d545bb4bc80e5d45858c373b20befa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b12946df5f2e6077e32620389a3c32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a90b12946df5f2e6077e32620389a3c32">isPacketOfType</a> (<a class="el" href="a00182.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> protocolType)</td></tr>
<tr class="separator:a90b12946df5f2e6077e32620389a3c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19addb15ea46927076227436fde753e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab19addb15ea46927076227436fde753e">computeCalculateFields</a> ()</td></tr>
<tr class="separator:ab19addb15ea46927076227436fde753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2ddb9a9ec2939b4f304129d691bdc9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5e2ddb9a9ec2939b4f304129d691bdc9">printToString</a> ()</td></tr>
<tr class="separator:a5e2ddb9a9ec2939b4f304129d691bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda6fc1afa7d8f3662360a927bec7f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#adda6fc1afa7d8f3662360a927bec7f82">printToStringList</a> (std::vector&lt; std::string &gt; &amp;result)</td></tr>
<tr class="separator:adda6fc1afa7d8f3662360a927bec7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a parsed packet. It contains the raw data (<a class="el" href="a00094.html">RawPacket</a> instance), and a linked list of layers, each layer is a parsed protocol that this packet contains. The layers linked list is ordered where the first layer is the lowest in the packet (currently it's always Ethernet protocol as PcapPlusPlus supports only Ethernet packets), the next layer will be L2.5 or L3 (e.g VLAN, IPv4, IPv6, etc.), and so on. etc.), etc. The last layer in the linked list will be the highest in the packet. For example: for a standard HTTP request packet the layer will look like this: <a class="el" href="a00017.html">EthLayer</a> -&gt; <a class="el" href="a00057.html">IPv4Layer</a> -&gt; <a class="el" href="a00128.html">TcpLayer</a> -&gt; <a class="el" href="a00028.html">HttpRequestLayer</a> <br />
 <a class="el" href="a00071.html">Packet</a> instance isn't read only. The user can add or remove layers, update current layer, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1a6d4e157661ba7ec6f552c78c82d7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPacketLen</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a new packet. Very useful when creating packets. When using this constructor an empty raw buffer is allocated (with the size of maxPacketLen) and a new <a class="el" href="a00094.html">RawPacket</a> is created </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPacketLen</td><td>The expected packet length in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9bf7d18a51920fe87c54ae234941816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="a00094.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="a00094.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="a00094.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac072415e151c3f8b2e55df859160d4dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="a00094.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="a00094.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="a00094.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="a00071.html">Packet</a> is free or not </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>A flag indicating if the destructor should also call the raw packet destructor or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54ccf8336cf3c3f6a5ad58ad12f06656"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pcpp::Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A destructor for this class. Frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="a00071.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer()</a> or <a class="el" href="a00071.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor) </p>

</div>
</div>
<a class="anchor" id="a11d603615d2f100eec547d51b4a6282e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor for this class. This copy constructor copies all the raw data and re-create all layers. So when the original <a class="el" href="a00071.html">Packet</a> is being freed, no data will be lost in the copied instance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af4c12806f2b320cdddd83a2b3a1136eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::addLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new layer as the last layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a class="anchor" id="ab19addb15ea46927076227436fde753e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::computeCalculateFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can have fields that can be calculate automatically from other fields using <a class="el" href="a00061.html#abea112176d18e896f48214ca7accac71">Layer::computeCalculateFields()</a>. This method forces all layers to calculate these fields values </p>

</div>
</div>
<a class="anchor" id="a02f98bcdd465eac96673752838826de4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00061.html">Layer</a>* pcpp::Packet::getFirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the first (lowest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the first (lowest) layer in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="a1c2dd7a761efe7393249ddc54bdd662b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00061.html">Layer</a>* pcpp::Packet::getLastLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the last (highest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the last (highest) layer in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="a78d0de95b49eb313e3184021234e5c5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getLayerOfType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get a layer of a certain type (protocol). If no layer of such type is found, NULL is returned </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a class="anchor" id="a1d545bb4bc80e5d45858c373b20befa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getNextLayerOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>after</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get the first layer of a certain type (protocol), start searching from a certain layer. For example: if a packet looks like: <a class="el" href="a00017.html">EthLayer</a> -&gt; VlanLayer(1) -&gt; VlanLayer(2) -&gt; VlanLayer(3) -&gt; <a class="el" href="a00057.html">IPv4Layer</a> and the user put VlanLayer(2) as a parameter and wishes to search for a <a class="el" href="a00136.html">VlanLayer</a>, VlanLayer(3) will be returned If no layer of such type is found, NULL is returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">after</td><td>A pointer to the layer to start search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a class="anchor" id="a7727ee05d4dc422ebe74c58ddd11cb22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html">RawPacket</a>* pcpp::Packet::getRawPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="a00071.html">Packet</a>'s <a class="el" href="a00094.html">RawPacket</a> </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="a00071.html">Packet</a>'s <a class="el" href="a00094.html">RawPacket</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8a88c7423642329409672f612990724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html">RawPacket</a>* pcpp::Packet::getRawPacketReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="a00071.html">Packet</a>'s <a class="el" href="a00094.html">RawPacket</a> in a read-only manner </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="a00071.html">Packet</a>'s <a class="el" href="a00094.html">RawPacket</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e2f9ea31fb1b7fa610db251405522f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::insertLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00061.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new layer after an existing layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to an existing layer in the packet which the new layer should followed by. If this layer isn't attached to a packet and error will be printed to log and false will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a class="anchor" id="a90b12946df5f2e6077e32620389a3c32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::isPacketOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00182.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocolType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the packet contains a certain protocol </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocolType</td><td>The protocol type to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet contains the protocol, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a26af180628893e454e9d6e0f2f1ebb98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00071.html">Packet</a>&amp; pcpp::Packet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00071.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator overloading. It first frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="a00071.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer()</a> or <a class="el" href="a00071.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor). Afterwards it copies the data from the other packet in the same way used in the copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e2ddb9a9ec2939b4f304129d691bdc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::Packet::printToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can print a string representation of the layer most important data using <a class="el" href="a00061.html#a3acb12ad2f7e10ed03fc3dd0ae22dbf7">Layer::toString()</a>. This method aggregates this string from all layers and print it to a complete string containing all packet's relevant data </p><dl class="section return"><dt>Returns</dt><dd>A string containing most relevant data from all layers (looks like the packet description in Wireshark) </dd></dl>

</div>
</div>
<a class="anchor" id="adda6fc1afa7d8f3662360a927bec7f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::printToStringList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="a00071.html#a5e2ddb9a9ec2939b4f304129d691bdc9">printToString()</a>, but instead of one string it outputs a list of strings, one string for every layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>A string vector that will contain all strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab751fc35d7e7b8a86e3f1fdbd2c30685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing layer from the packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>The layer to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a class="anchor" id="a5ebf994984d94f2ffacb367172cfad08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::setRawPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a <a class="el" href="a00094.html">RawPacket</a> and re-construct all packet layers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>Raw packet to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>A flag indicating if the destructor should also call the raw packet destructor or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00182.html">pcpp</a></li><li class="navelem"><a class="el" href="a00071.html">Packet</a></li>
    <li class="footer">Generated on Mon May 23 2016 00:43:09 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
