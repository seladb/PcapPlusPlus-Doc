<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::PcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01235.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a01232.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::PcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00092_source.html">PcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::PcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a01235.png" usemap="#pcpp::PcapLiveDevice_map" alt=""/>
  <map id="pcpp::PcapLiveDevice_map" name="pcpp::PcapLiveDevice_map">
<area href="a01127.html" alt="pcpp::IPcapDevice" shape="rect" coords="85,0,245,24"/>
<area href="a01247.html" alt="pcpp::PcapRemoteDevice" shape="rect" coords="0,112,160,136"/>
<area href="a01535.html" alt="pcpp::WinPcapLiveDevice" shape="rect" coords="170,112,330,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e343585711ee4e02d4b9507467135ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> { <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652">LibPcapDevice</a>, 
<a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6">WinPcapDevice</a>, 
<a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c">RemoteDevice</a>
 }</td></tr>
<tr class="separator:a0e343585711ee4e02d4b9507467135ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381e7f053285090f0f9620bcbd8f0f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> { <a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf">Normal</a> = 0, 
<a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca">Promiscuous</a> = 1
 }</td></tr>
<tr class="separator:a2381e7f053285090f0f9620bcbd8f0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0172bbe45fb66f4722bf2bd4847c91fe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a0172bbe45fb66f4722bf2bd4847c91fe">~PcapLiveDevice</a> ()</td></tr>
<tr class="separator:a0172bbe45fb66f4722bf2bd4847c91fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b3e39208905585907c3557971b71e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a70b3e39208905585907c3557971b71e8">getDeviceType</a> ()</td></tr>
<tr class="separator:a70b3e39208905585907c3557971b71e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d887cb3005e75cc67609b957a886c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a606d887cb3005e75cc67609b957a886c">getName</a> ()</td></tr>
<tr class="separator:a606d887cb3005e75cc67609b957a886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdd1317bb1387a067bfd21d49e5b059"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#aacdd1317bb1387a067bfd21d49e5b059">getDesc</a> ()</td></tr>
<tr class="separator:aacdd1317bb1387a067bfd21d49e5b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75748fd040d8f97f4c43b1524e4fb479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a75748fd040d8f97f4c43b1524e4fb479">getLoopback</a> ()</td></tr>
<tr class="separator:a75748fd040d8f97f4c43b1524e4fb479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c3eb2f9d1af368fa0d9da30ef60f9b"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ae9c3eb2f9d1af368fa0d9da30ef60f9b">getMtu</a> ()</td></tr>
<tr class="separator:ae9c3eb2f9d1af368fa0d9da30ef60f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a1a299d54e2150eedf96f90ad5caa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pcap_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a5a9a1a299d54e2150eedf96f90ad5caa">getAddresses</a> ()</td></tr>
<tr class="separator:a5a9a1a299d54e2150eedf96f90ad5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfa0fc4bc0374aaf9f11333a9904110"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a01095.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a1bfa0fc4bc0374aaf9f11333a9904110">getMacAddress</a> ()</td></tr>
<tr class="separator:a1bfa0fc4bc0374aaf9f11333a9904110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb6a59e454d6594451e4b285344181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00967.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a36fb6a59e454d6594451e4b285344181">getIPv4Address</a> ()</td></tr>
<tr class="separator:a36fb6a59e454d6594451e4b285344181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df16cfa57eea8f275d8ddfecfee968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00967.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ab7df16cfa57eea8f275d8ddfecfee968">getDefaultGateway</a> ()</td></tr>
<tr class="separator:ab7df16cfa57eea8f275d8ddfecfee968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cdf86d684d71cf556cd9dd98f1a9c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00967.html">IPv4Address</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a89cdf86d684d71cf556cd9dd98f1a9c6">getDnsServers</a> ()</td></tr>
<tr class="separator:a89cdf86d684d71cf556cd9dd98f1a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b001c38b0f1e43a1691fedbd1b0cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture</a> (<a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:a349b001c38b0f1e43a1691fedbd1b0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78306fe44879e457df4043a117f6863a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a78306fe44879e457df4043a117f6863a">startCapture</a> (<a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a78306fe44879e457df4043a117f6863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2933139d284d7c167283982ec8b56559"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2933139d284d7c167283982ec8b56559">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a2933139d284d7c167283982ec8b56559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821bbac1ffad5a75c6a0be1ff362eb9f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a821bbac1ffad5a75c6a0be1ff362eb9f">startCapture</a> (<a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:a821bbac1ffad5a75c6a0be1ff362eb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479987f8faf52328061e18af2addcc5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ae479987f8faf52328061e18af2addcc5">startCaptureBlockingMode</a> (<a class="el" href="a00179.html#a1fb7ed19d0cb6b09ab2b1d0570b64cb4">OnPacketArrivesStopBlocking</a> onPacketArrives, void *userCookie, int timeout)</td></tr>
<tr class="separator:ae479987f8faf52328061e18af2addcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818da3e11e0c953385badf6233ee0f43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture</a> ()</td></tr>
<tr class="separator:a818da3e11e0c953385badf6233ee0f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7b9be7551ad7759c32e9d5fbabd5c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2e7b9be7551ad7759c32e9d5fbabd5c8">sendPacket</a> (<a class="el" href="a01291.html">RawPacket</a> const &amp;rawPacket)</td></tr>
<tr class="separator:a2e7b9be7551ad7759c32e9d5fbabd5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f45c8bc2c370f3f2120909f36b22802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2f45c8bc2c370f3f2120909f36b22802">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:a2f45c8bc2c370f3f2120909f36b22802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa547d006ea10328c631eb5379798dede"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#aa547d006ea10328c631eb5379798dede">sendPacket</a> (<a class="el" href="a01115.html">Packet</a> *packet)</td></tr>
<tr class="separator:aa547d006ea10328c631eb5379798dede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8df597d7d931fce5d006f20c9fbce3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#acf8df597d7d931fce5d006f20c9fbce3">sendPackets</a> (<a class="el" href="a01291.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:acf8df597d7d931fce5d006f20c9fbce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9efc27c7c0778d47c94dac02defa22b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#af9efc27c7c0778d47c94dac02defa22b">sendPackets</a> (<a class="el" href="a01115.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:af9efc27c7c0778d47c94dac02defa22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb039496514f3c53bc7eca2235653c70"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#adb039496514f3c53bc7eca2235653c70">sendPackets</a> (const <a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:adb039496514f3c53bc7eca2235653c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281f2cd6062791c68ecdd82384f751f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open</a> ()</td></tr>
<tr class="separator:a281f2cd6062791c68ecdd82384f751f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccb5eac1b23651e7b157b628435528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ad7ccb5eac1b23651e7b157b628435528">close</a> ()</td></tr>
<tr class="separator:ad7ccb5eac1b23651e7b157b628435528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f87416b25abe3b625f0f9993bb7e1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a68f87416b25abe3b625f0f9993bb7e1b">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a68f87416b25abe3b625f0f9993bb7e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e61feb22fdab2bbbff8da63751169c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a5e61feb22fdab2bbbff8da63751169c9">open</a> (<a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> mode)</td></tr>
<tr class="separator:a5e61feb22fdab2bbbff8da63751169c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a01127"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a01127')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a01127.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a22b03cdabb9f359c6bed0728c3614789">isOpened</a> ()</td></tr>
<tr class="separator:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#aadba6a20265dca6ba29b548325a798fe">setFilter</a> (<a class="el" href="a01159.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a134f061d7883abbdb256abd48d53e66c">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#aba28d535c6aa05e9f9492c82ece25de7">clearFilter</a> ()</td></tr>
<tr class="separator:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a01127"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a01127')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a01127.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a01127"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a5cc546829570cd981bfa762acd9759c8">verifyFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a01127"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a54df47e98feadfd830789ca3a7f5f86b">matchPakcetWithFilter</a> (std::string filterAsString, <a class="el" href="a01291.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a network interface (each of the interfaces listed in ifconfig/ipconfig). This class wraps the libpcap capabilities of capturing packets from the network, filtering packets and sending packets back to the network. This class is relevant for Linux applications only. On Windows the <a class="el" href="a01535.html">WinPcapLiveDevice</a> (which inherits this class) is used. Both classes are almost similar in capabilities, the main difference between them is adapting some capabilities to the specific OS. This class cannot be instantiated by the user (it has a private constructor), as network interfaces aren't dynamic. Instances of this class (one instance per network interface) are created by <a class="el" href="a01239.html">PcapLiveDeviceList</a> singleton on application startup and the user can get access to them by using <a class="el" href="a01239.html">PcapLiveDeviceList</a> public methods such as <a class="el" href="a01239.html#a1ab7bad31dbb97247648d1a149d2f612">PcapLiveDeviceList::getPcapLiveDeviceByIp()</a><br />
 Main capabilities of this class:</p><ul>
<li>Get all available information for this network interfaces such as name, IP addresses, MAC address, MTU, etc. This information is taken from both libpcap and the OS</li>
<li>Capture packets from the network. Capturing is always conducted on a different thread. PcapPlusPlus creates this thread when capturing starts and kills it when capturing ends. This prevents the application from being stuck while waiting for packets or processing them. Currently only one capturing thread is allowed, so when the interface is in capture mode, no further capturing is allowed. In addition to capturing the user can get stats on packets that were received by the application, dropped by the NIC (due to full NIC buffers), etc. Stats collection can be initiated by the user by calling <a class="el" href="a01235.html#a68f87416b25abe3b625f0f9993bb7e1b">getStatistics()</a> or be pushed to the user periodically by supplying a callback and a timeout to <a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a></li>
<li>Send packets back to the network. Sending the packets is done on the caller thread. No additional threads are created for this task </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2381e7f053285090f0f9620bcbd8f0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2381e7f053285090f0f9620bcbd8f0f3">&#9670;&nbsp;</a></span>DeviceMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">pcpp::PcapLiveDevice::DeviceMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device capturing mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf"></a>Normal&#160;</td><td class="fielddoc"><p>Only packets that their destination is this NIC are captured </p>
</td></tr>
<tr><td class="fieldname"><a id="a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca"></a>Promiscuous&#160;</td><td class="fielddoc"><p>All packets that arrive to the NIC are captured, even packets that their destination isn't this NIC </p>
</td></tr>
</table>

</div>
</div>
<a id="a0e343585711ee4e02d4b9507467135ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e343585711ee4e02d4b9507467135ab">&#9670;&nbsp;</a></span>LiveDeviceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">pcpp::PcapLiveDevice::LiveDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the live device </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652"></a>LibPcapDevice&#160;</td><td class="fielddoc"><p>libPcap live device </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6"></a>WinPcapDevice&#160;</td><td class="fielddoc"><p>WinPcap live device </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c"></a>RemoteDevice&#160;</td><td class="fielddoc"><p>WinPcap Remote Capture device </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0172bbe45fb66f4722bf2bd4847c91fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0172bbe45fb66f4722bf2bd4847c91fe">&#9670;&nbsp;</a></span>~PcapLiveDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pcpp::PcapLiveDevice::~PcapLiveDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A destructor for this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7ccb5eac1b23651e7b157b628435528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ccb5eac1b23651e7b157b628435528">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PcapLiveDevice::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the device </p>

<p>Implements <a class="el" href="a01127.html#a5ce8877d4e047f11a3cb8d0f4f527e56">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a id="a5a9a1a299d54e2150eedf96f90ad5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a1a299d54e2150eedf96f90ad5caa">&#9670;&nbsp;</a></span>getAddresses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;pcap_addr_t&gt;&amp; pcpp::PcapLiveDevice::getAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector containing all addresses defined for this interface, each in pcap_addr_t struct </dd></dl>

</div>
</div>
<a id="ab7df16cfa57eea8f275d8ddfecfee968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df16cfa57eea8f275d8ddfecfee968">&#9670;&nbsp;</a></span>getDefaultGateway()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00967.html">IPv4Address</a> pcpp::PcapLiveDevice::getDefaultGateway </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The default gateway defined for this interface. If no default gateway is defined, if it's not IPv4 or if couldn't extract default gateway <a class="el" href="a00967.html#ab1fdcb75a0d28033e51770605ec978cb">IPv4Address::Zero</a> will be returned. If multiple gateways were defined the first one will be returned </dd></dl>

</div>
</div>
<a id="aacdd1317bb1387a067bfd21d49e5b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdd1317bb1387a067bfd21d49e5b059">&#9670;&nbsp;</a></span>getDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcpp::PcapLiveDevice::getDesc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A human-readable description of the device, taken from pcap_if_t-&gt;description. May be NULL in some interfaces </dd></dl>

</div>
</div>
<a id="a70b3e39208905585907c3557971b71e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b3e39208905585907c3557971b71e8">&#9670;&nbsp;</a></span>getDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> pcpp::PcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap or a remote device) </dd></dl>

<p>Reimplemented in <a class="el" href="a01247.html#af5518431a35a7f94b6ee8551061eee18">pcpp::PcapRemoteDevice</a>, and <a class="el" href="a01535.html#acc1fc2d75dc09c9e3920c6c1d3f0ce37">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="a89cdf86d684d71cf556cd9dd98f1a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cdf86d684d71cf556cd9dd98f1a9c6">&#9670;&nbsp;</a></span>getDnsServers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00967.html">IPv4Address</a>&gt;&amp; pcpp::PcapLiveDevice::getDnsServers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A list of all DNS servers defined for this machine. If this list is empty it means no DNS servers were defined or they couldn't be extracted from some reason. This list is created in <a class="el" href="a01239.html">PcapLiveDeviceList</a> class and can be also retrieved from there. This method exists for convenience - so it'll be possible to get this list from <a class="el" href="a01235.html">PcapLiveDevice</a> as well </dd></dl>

</div>
</div>
<a id="a36fb6a59e454d6594451e4b285344181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6a59e454d6594451e4b285344181">&#9670;&nbsp;</a></span>getIPv4Address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00967.html">IPv4Address</a> pcpp::PcapLiveDevice::getIPv4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The IPv4 address for this interface. If multiple IPv4 addresses are defined for this interface, the first will be picked. If no IPv4 addresses are defined, a zeroed IPv4 address (<a class="el" href="a00967.html#ab1fdcb75a0d28033e51770605ec978cb">IPv4Address::Zero</a>) will be returned </dd></dl>

</div>
</div>
<a id="a75748fd040d8f97f4c43b1524e4fb479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75748fd040d8f97f4c43b1524e4fb479">&#9670;&nbsp;</a></span>getLoopback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::getLoopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this interface is a loopback interface, false otherwise </dd></dl>

</div>
</div>
<a id="a1bfa0fc4bc0374aaf9f11333a9904110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfa0fc4bc0374aaf9f11333a9904110">&#9670;&nbsp;</a></span>getMacAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a01095.html">MacAddress</a> pcpp::PcapLiveDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The MAC address for this interface </dd></dl>

<p>Reimplemented in <a class="el" href="a01247.html#a3006b9fb3ce13dde29409e0ef47c4377">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="ae9c3eb2f9d1af368fa0d9da30ef60f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c3eb2f9d1af368fa0d9da30ef60f9b">&#9670;&nbsp;</a></span>getMtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t pcpp::PcapLiveDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's maximum transmission unit (MTU) in bytes </dd></dl>

<p>Reimplemented in <a class="el" href="a01247.html#a242bf2bdafb0b1d2aed2b266cad9e5bd">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a606d887cb3005e75cc67609b957a886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606d887cb3005e75cc67609b957a886c">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcpp::PcapLiveDevice::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the device (e.g eth0), taken from pcap_if_t-&gt;name </dd></dl>

</div>
</div>
<a id="a68f87416b25abe3b625f0f9993bb7e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f87416b25abe3b625f0f9993bb7e1b">&#9670;&nbsp;</a></span>getStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pcpp::PcapLiveDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get statistics from device:</p><ul>
<li>pcap_stat::ps_recv: number of packets received</li>
<li>pcap_stat::ps_drop: number of packets dropped</li>
<li>pcap_stat::ps_ifdorp: number of packets dropped by interface <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>The stats struct where stats are returned </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Implements <a class="el" href="a01127.html#ace3640f2330899687e34aa3789f4cd05">pcpp::IPcapDevice</a>.</p>

<p>Reimplemented in <a class="el" href="a01247.html#ac4f3b9ace451b38aa9930950dc695273">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a281f2cd6062791c68ecdd82384f751f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281f2cd6062791c68ecdd82384f751f8">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the device using libpcap pcap_open_live. Opening the device only makes the device ready for use, it doesn't start packet capturing. For packet capturing the user should call <a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a>. This implies that calling this method is a must before calling <a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a> (otherwise <a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture()</a> will fail with a "device not open" error). The device is opened in promiscuous mode </p><dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false otherwise. When opening the device fails an error will be printed to log as well </dd></dl>

<p>Implements <a class="el" href="a01127.html#aa7d1358756653febf63d23b21447649c">pcpp::IPcapDevice</a>.</p>

<p>Reimplemented in <a class="el" href="a01247.html#a2b9e2ac456a61dcd739cfd7de0b827df">pcpp::PcapRemoteDevice</a>.</p>

</div>
</div>
<a id="a5e61feb22fdab2bbbff8da63751169c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e61feb22fdab2bbbff8da63751169c9">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a>, but enables to open the device in normal or promiscuous mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Normal or promiscuous mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> </dd></dl>

</div>
</div>
<a id="a2e7b9be7551ad7759c32e9d5fbabd5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7b9be7551ad7759c32e9d5fbabd5c8">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01291.html">RawPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a <a class="el" href="a01291.html">RawPacket</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A reference to the raw packet to send. This method treats the raw packet as read-only, it doesn't change anything in it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2f45c8bc2c370f3f2120909f36b22802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f45c8bc2c370f3f2120909f36b22802">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a buffer containing packet raw data (including all layers) to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The buffer containing the packet raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>The length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa547d006ea10328c631eb5379798dede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa547d006ea10328c631eb5379798dede">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01115.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a parsed <a class="el" href="a01115.html">Packet</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the packet to send. This method treats the packet as read-only, it doesn't change anything in it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acf8df597d7d931fce5d006f20c9fbce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8df597d7d931fce5d006f20c9fbce3">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01291.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="a01291.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The array of <a class="el" href="a01291.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a01535.html#a8f0f1d43beaf1e839959ec51838a246f">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="af9efc27c7c0778d47c94dac02defa22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9efc27c7c0778d47c94dac02defa22b">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01115.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of pointers to <a class="el" href="a01115.html">Packet</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>The array of pointers to <a class="el" href="a01115.html">Packet</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adb039496514f3c53bc7eca2235653c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb039496514f3c53bc7eca2235653c70">&#9670;&nbsp;</a></span>sendPackets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPackets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a vector of pointers to <a class="el" href="a01291.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPackets</td><td>The array of pointers to <a class="el" href="a01291.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a349b001c38b0f1e43a1691fedbd1b0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349b001c38b0f1e43a1691fedbd1b0cc">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). Each time a packet is captured the onPacketArrives callback is called. The capture is done on a new thread created by this method, meaning all callback calls are done in a thread other than the caller thread. Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a78306fe44879e457df4043a117f6863a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78306fe44879e457df4043a117f6863a">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a01535.html#af22e2966176d4127e69300cd4b208758">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="a2933139d284d7c167283982ec8b56559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2933139d284d7c167283982ec8b56559">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a01535.html#a70126c098779937e5ce88360966c7aa1">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="a821bbac1ffad5a75c6a0be1ff362eb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821bbac1ffad5a75c6a0be1ff362eb9f">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pcpp::PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="a01291.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="a01291.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a01535.html#a74824694b8f72f687dec10557a196675">pcpp::WinPcapLiveDevice</a>.</p>

</div>
</div>
<a id="ae479987f8faf52328061e18af2addcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae479987f8faf52328061e18af2addcc5">&#9670;&nbsp;</a></span>startCaptureBlockingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::PcapLiveDevice::startCaptureBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#a1fb7ed19d0cb6b09ab2b1d0570b64cb4">OnPacketArrivesStopBlocking</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) in blocking mode, meaning this method blocks and won't return until the user frees the blocking (via onPacketArrives callback) or until a user defined timeout expires. Whenever a packets is captured the onPacketArrives callback is called and lets the user handle the packet. In each callback call the user should return true if he wants to release the block or false if it wants it to keep blocking. Regardless of this callback a timeout is defined when start capturing. When this timeout expires the method will return.<br />
 Please notice that <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a> isn't needed here because when the method returns (after timeout or per user decision) capturing on the device is stopped </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback given by the user for handling incoming packets. After handling each packet the user needs to return a boolean value. True value indicates stop capturing and stop blocking and false value indicates continue capturing and blocking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>A timeout in seconds for the blocking to stop even if the user didn't return "true" in the onPacketArrives callback If this timeout is set to 0 or less the timeout will be ignored, meaning the method will keep blocking until the user frees it via the onPacketArrives callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if timeout expired, 1 if blocking was stopped via onPacketArrives callback or 0 if an error occurred (such as device not open etc.). When returning 0 an appropriate error message is printed to log </dd></dl>

</div>
</div>
<a id="a818da3e11e0c953385badf6233ee0f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818da3e11e0c953385badf6233ee0f43">&#9670;&nbsp;</a></span>stopCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PcapLiveDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a currently running packet capture. This method terminates gracefully both packet capture thread and periodic stats collection thread (both if exist) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00179.html">pcpp</a></li><li class="navelem"><a class="el" href="a01235.html">PcapLiveDevice</a></li>
    <li class="footer">Generated on Sat Aug 4 2018 23:35:14 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
