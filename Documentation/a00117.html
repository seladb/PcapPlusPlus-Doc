<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: pcpp::PfRingDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00117.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00370.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::PfRingDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00226_source.html">PfRingDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::PfRingDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00117.png" usemap="#pcpp::PfRingDevice_map" alt=""/>
  <map id="pcpp::PfRingDevice_map" name="pcpp::PfRingDevice_map">
<area href="a00068.html" alt="pcpp::IPcapDevice" shape="rect" coords="0,0,123,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a7113725490fea52c9702998e6a8f78"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a> { <a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78a707c1b0c55e37f2cb7d4978370332712">RoundRobin</a>, 
<a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78a7b91b5daaad7f4b2f754afa4b69f48b6">PerFlow</a>
 }</td></tr>
<tr class="separator:a2a7113725490fea52c9702998e6a8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72463fcbd7eae62523c58fec6ecd2385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a72463fcbd7eae62523c58fec6ecd2385">~PfRingDevice</a> ()</td></tr>
<tr class="separator:a72463fcbd7eae62523c58fec6ecd2385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f349a204036f5de153e5a45e1a4f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00096.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ab3f349a204036f5de153e5a45e1a4f50">getMacAddress</a> ()</td></tr>
<tr class="separator:ab3f349a204036f5de153e5a45e1a4f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d939956173c6246d02aa5bcbc576c0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a9d939956173c6246d02aa5bcbc576c0f">getInterfaceIndex</a> ()</td></tr>
<tr class="separator:a9d939956173c6246d02aa5bcbc576c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a783b9949814723e1e3e7dc76c5e4fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a3a783b9949814723e1e3e7dc76c5e4fc">getMtu</a> ()</td></tr>
<tr class="separator:a3a783b9949814723e1e3e7dc76c5e4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d897e1f5c1f9ef15987b82eff1a736b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a3d897e1f5c1f9ef15987b82eff1a736b">isHwClockEnabledForDevice</a> ()</td></tr>
<tr class="separator:a3d897e1f5c1f9ef15987b82eff1a736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f9514b06cef4dd7abed9a76ffd5344"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a83f9514b06cef4dd7abed9a76ffd5344">getDeviceName</a> ()</td></tr>
<tr class="separator:a83f9514b06cef4dd7abed9a76ffd5344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d15fc696287e4a5dc16bd809fdce893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a2d15fc696287e4a5dc16bd809fdce893">startCaptureSingleThread</a> (OnPfRingPacketsArriveCallback onPacketsArrive, void *onPacketsArriveUserCookie)</td></tr>
<tr class="separator:a2d15fc696287e4a5dc16bd809fdce893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267f74af554b8651d771ab7f453dc50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a2267f74af554b8651d771ab7f453dc50">startCaptureMultiThread</a> (OnPfRingPacketsArriveCallback onPacketsArrive, void *onPacketsArriveUserCookie, CoreMask coreMask)</td></tr>
<tr class="separator:a2267f74af554b8651d771ab7f453dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d086cb96e4e8de1e1d5ee640812575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a31d086cb96e4e8de1e1d5ee640812575">stopCapture</a> ()</td></tr>
<tr class="separator:a31d086cb96e4e8de1e1d5ee640812575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a06e5e4364538de4b4fc71df0153c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a4a06e5e4364538de4b4fc71df0153c27">openSingleRxChannel</a> (uint8_t channelId)</td></tr>
<tr class="separator:a4a06e5e4364538de4b4fc71df0153c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fa6c928456417a5985be210e3e487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels</a> (const uint8_t *channelIds, int numOfChannelIds)</td></tr>
<tr class="separator:a923fa6c928456417a5985be210e3e487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fa0b515215e8801f3e5f955dff095c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a42fa0b515215e8801f3e5f955dff095c">openMultiRxChannels</a> (uint8_t numOfRxChannelsToOpen, <a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a> dist)</td></tr>
<tr class="separator:a42fa0b515215e8801f3e5f955dff095c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984de29bb1e6f42231c1b650c92f0969"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a984de29bb1e6f42231c1b650c92f0969">getNumOfOpenedRxChannels</a> ()</td></tr>
<tr class="separator:a984de29bb1e6f42231c1b650c92f0969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0454ec800c301f67d9679b8159e91c14"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a0454ec800c301f67d9679b8159e91c14">getTotalNumOfRxChannels</a> ()</td></tr>
<tr class="separator:a0454ec800c301f67d9679b8159e91c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e51de995525ddc5f1bfd8dd20fd3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00170.html">SystemCore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a45e51de995525ddc5f1bfd8dd20fd3bf">getCurrentCoreId</a> ()</td></tr>
<tr class="separator:a45e51de995525ddc5f1bfd8dd20fd3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f06d907a5727d2cc22ac9c72038f23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ab5f06d907a5727d2cc22ac9c72038f23">getThreadStatistics</a> (<a class="el" href="a00170.html">SystemCore</a> core, pcap_stat &amp;stats)</td></tr>
<tr class="separator:ab5f06d907a5727d2cc22ac9c72038f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e803aad35adbdf88e6590aab61b050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ad9e803aad35adbdf88e6590aab61b050">getCurrentThreadStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:ad9e803aad35adbdf88e6590aab61b050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f3512928cf7ccdb4f8a28532c6ee51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a94f3512928cf7ccdb4f8a28532c6ee51">open</a> ()</td></tr>
<tr class="separator:a94f3512928cf7ccdb4f8a28532c6ee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9df26e45654c94c08bfd73c0c18474d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ad9df26e45654c94c08bfd73c0c18474d">close</a> ()</td></tr>
<tr class="separator:ad9df26e45654c94c08bfd73c0c18474d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d704b9bfa52548f1abbed7d50d98d03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a0d704b9bfa52548f1abbed7d50d98d03">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a0d704b9bfa52548f1abbed7d50d98d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad800a59610471331d9baa42dacbcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ac4ad800a59610471331d9baa42dacbcf">setFilter</a> (<a class="el" href="a00022.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:ac4ad800a59610471331d9baa42dacbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd683b41cf717a08248ddf86b08df49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#addd683b41cf717a08248ddf86b08df49">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:addd683b41cf717a08248ddf86b08df49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91748cb114ccef418cccc7aa2db5f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ac91748cb114ccef418cccc7aa2db5f17">removeFilter</a> ()</td></tr>
<tr class="separator:ac91748cb114ccef418cccc7aa2db5f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad955fa2fcd4634a27196118782040fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#ad955fa2fcd4634a27196118782040fca">isFilterCurrentlySet</a> ()</td></tr>
<tr class="separator:ad955fa2fcd4634a27196118782040fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5f1744d29145bf929e943c02f35a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a1a5f1744d29145bf929e943c02f35a6b">sendPacket</a> (const <a class="el" href="a00130.html">RawPacket</a> &amp;rawPacket)</td></tr>
<tr class="separator:a1a5f1744d29145bf929e943c02f35a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe92b5e338eeb7086527b9f468e1a05e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#abe92b5e338eeb7086527b9f468e1a05e">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:abe92b5e338eeb7086527b9f468e1a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbdc286e019385205d4528d80af9484"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a8cbdc286e019385205d4528d80af9484">sendPacket</a> (const <a class="el" href="a00104.html">Packet</a> &amp;packet)</td></tr>
<tr class="separator:a8cbdc286e019385205d4528d80af9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af825fb6acf7cfbc6da7dd19f854be1ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets</a> (const <a class="el" href="a00130.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:af825fb6acf7cfbc6da7dd19f854be1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a8fabac9d1c87b2a6e79d5ce0bbfb7eeb">sendPackets</a> (const <a class="el" href="a00104.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9259bcfd0d7e94822ec2a2930314c52e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html#a9259bcfd0d7e94822ec2a2930314c52e">sendPackets</a> (const <a class="el" href="a00247.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:a9259bcfd0d7e94822ec2a2930314c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00068"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00068')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00068.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a22b03cdabb9f359c6bed0728c3614789">isOpened</a> ()</td></tr>
<tr class="separator:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#aadba6a20265dca6ba29b548325a798fe">setFilter</a> (<a class="el" href="a00022.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#aba28d535c6aa05e9f9492c82ece25de7">clearFilter</a> ()</td></tr>
<tr class="separator:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a00068"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00068')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a00068.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00068"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a5cc546829570cd981bfa762acd9759c8">verifyFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00068"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a54df47e98feadfd830789ca3a7f5f86b">matchPakcetWithFilter</a> (std::string filterAsString, <a class="el" href="a00130.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a PF_RING port </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a2a7113725490fea52c9702998e6a8f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78">pcpp::PfRingDevice::ChannelDistribution</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum representing the type of packet distribution between different RX channels </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2a7113725490fea52c9702998e6a8f78a707c1b0c55e37f2cb7d4978370332712"></a>RoundRobin&#160;</td><td class="fielddoc">
<p>Packets are distributed between channels in a round-robin manner </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2a7113725490fea52c9702998e6a8f78a7b91b5daaad7f4b2f754afa4b69f48b6"></a>PerFlow&#160;</td><td class="fielddoc">
<p>Packets are distributed between channels per flow (each flow goes for different channel) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a72463fcbd7eae62523c58fec6ecd2385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::PfRingDevice::~PfRingDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A destructor for <a class="el" href="a00117.html">PfRingDevice</a> class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad9df26e45654c94c08bfd73c0c18474d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes all RX channels currently opened in device </p>

<p>Implements <a class="el" href="a00068.html#a5ce8877d4e047f11a3cb8d0f4f527e56">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a45e51de995525ddc5f1bfd8dd20fd3bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00170.html">SystemCore</a> pcpp::PfRingDevice::getCurrentCoreId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the core used in the current thread context </p><dl class="section return"><dt>Returns</dt><dd>The system core used in the current thread context </dd></dl>

</div>
</div>
<a class="anchor" id="ad9e803aad35adbdf88e6590aab61b050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getCurrentThreadStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics of the current thread/core (=RX channel) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overriden </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83f9514b06cef4dd7abed9a76ffd5344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::PfRingDevice::getDeviceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the interface name (e.g eth0, eth1, etc.) </p><dl class="section return"><dt>Returns</dt><dd>The interface name </dd></dl>

</div>
</div>
<a class="anchor" id="a9d939956173c6246d02aa5bcbc576c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::getInterfaceIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get PF_RING interface index of the current device </p><dl class="section return"><dt>Returns</dt><dd>PF_RING interface index of the current device </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f349a204036f5de153e5a45e1a4f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">MacAddress</a> pcpp::PfRingDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the MAC address of the current device </p><dl class="section return"><dt>Returns</dt><dd>The MAC address of the current device </dd></dl>

</div>
</div>
<a class="anchor" id="a3a783b9949814723e1e3e7dc76c5e4fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get MTU of the current device </p><dl class="section return"><dt>Returns</dt><dd>Upon success return the device MTU, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a984de29bb1e6f42231c1b650c92f0969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pcpp::PfRingDevice::getNumOfOpenedRxChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the number of RX channels currently open. RX channels aren't necessary interface's RX queues because in some cases the user asks to open several channels on the same queue. For example: if the user uses <a class="el" href="a00117.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels()</a> and asks to open 8 channels but interface has only 4 RX queues, 2 channels will be opened for each RX queue </p><dl class="section return"><dt>Returns</dt><dd>Number of opened RX channels </dd></dl>

</div>
</div>
<a class="anchor" id="a0d704b9bfa52548f1abbed7d50d98d03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the statistics for the entire device. If more than 1 RX channel is opened, this method aggregates the stats of all channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overriden </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00068.html#ace3640f2330899687e34aa3789f4cd05">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ab5f06d907a5727d2cc22ac9c72038f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::getThreadStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00170.html">SystemCore</a>&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics of a specific thread/core (=RX channel) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">core</td><td>The requested core </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference for the stats object where the stats are written. Current values will be overriden </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0454ec800c301f67d9679b8159e91c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pcpp::PfRingDevice::getTotalNumOfRxChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the total number of RX channels (RX queues) this interface has </p><dl class="section return"><dt>Returns</dt><dd>The number of RX channels (queues) for this interface </dd></dl>

</div>
</div>
<a class="anchor" id="ad955fa2fcd4634a27196118782040fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::isFilterCurrentlySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if filter is currently set </p><dl class="section return"><dt>Returns</dt><dd>True if filter is currently set, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a3d897e1f5c1f9ef15987b82eff1a736b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::isHwClockEnabledForDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if device supports hardware timestamping. If it does, this feature will be automatically set for this device. You can read more about this in PF_RING documentation </p><dl class="section return"><dt>Returns</dt><dd>True if device supports hardware timestamping, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a94f3512928cf7ccdb4f8a28532c6ee51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens the entire device (including all RX channels/queues on this interface). All packets will be received on a single thread without core affinity </p><dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

<p>Implements <a class="el" href="a00068.html#aa7d1358756653febf63d23b21447649c">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a923fa6c928456417a5985be210e3e487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openMultiRxChannels </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>channelIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numOfChannelIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a set of RX channels (=RX queues) on this interface, identified by their IDs. All packets will be received on a single thread without core affinity. If one of the channel IDs requested doesn't exist on this interface, the method will fail (return false) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelIds</td><td>An array of channel IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfChannelIds</td><td>The channel ID array size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a42fa0b515215e8801f3e5f955dff095c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openMultiRxChannels </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numOfRxChannelsToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00117.html#a2a7113725490fea52c9702998e6a8f78">ChannelDistribution</a>&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens numOfRxChannelsToOpen RX channels. If numOfRxChannelsToOpen is larger than available RX queues for this interface than a number of RX channels will be opened on each RX queue. For example: if the user asks for 10 RX channels but the interface has only 4 RX queues, then 3 RX channels will be opened for RX-queue0 and RX-queue2, and 2 RX channels will be opened for RX-queue2 and RX-queue3. Packets will be distributed between different RX queues on per-flow manner, but within multiple RX channels in the same RX queue packet will be distributed according to distribution requested by "dist" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfRxChannelsToOpen</td><td>Number of RX channels to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dist</td><td>Distribution method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a4a06e5e4364538de4b4fc71df0153c27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::openSingleRxChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a single RX channel (=RX queue) on this interface. All packets will be received on a single thread without core affinity. If the channel ID requested doesn't exist on this interface, the method will fail (return false) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channelId</td><td>The requested channel ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac91748cb114ccef418cccc7aa2db5f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::removeFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a filter if currently set </p><dl class="section return"><dt>Returns</dt><dd>True if filter was removed successfully or if no filter was set, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1a5f1744d29145bf929e943c02f35a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00130.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a raw packet. This packet must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets In the burst please use <a class="el" href="a00117.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The raw packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abe92b5e338eeb7086527b9f468e1a05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send raw data. This data must be a valid and fully specified packet (the MAC address up); it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets in the burst please use <a class="el" href="a00117.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The raw data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>the length of packetData </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbdc286e019385205d4528d80af9484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00104.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a packet. This packet must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the data in any way (hence the "const" declaration). Note this method flushes the TX queues after the data is sent. So if you want to send several packets In the burst please use <a class="el" href="a00117.html#af825fb6acf7cfbc6da7dd19f854be1ad">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The packet to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if raw packet was sent completely, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af825fb6acf7cfbc6da7dd19f854be1ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00130.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send raw packets. All raw packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the raw packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The <a class="el" href="a00130.html">RawPacket</a> array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td><a class="el" href="a00130.html">RawPacket</a> array length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets that were sent completely </dd></dl>

</div>
</div>
<a class="anchor" id="a8fabac9d1c87b2a6e79d5ce0bbfb7eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00104.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send packets. All packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>An array of pointers to <a class="el" href="a00104.html">Packet</a> objects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td><a class="el" href="a00104.html">Packet</a> pointers array length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets that were sent completely </dd></dl>

</div>
</div>
<a class="anchor" id="a9259bcfd0d7e94822ec2a2930314c52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::PfRingDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00247.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPackets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send all raw packets pointed by the RawPacketVector. All packets must be fully specified (the MAC address up) and it will be transmitted as-is without any further manipulation. This method doesn't change or manipulate the packets data in any way (hence the "const" declaration). This method flushes the TX queues only when the last packet is sent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPackets</td><td>The raw packet vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of raw packets that were sent completely </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ad800a59610471331d9baa42dacbcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">GeneralFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a filter to the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addd683b41cf717a08248ddf86b08df49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filterAsString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a BPF filter to the device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filterAsString</td><td>The BPF filter in string format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00068.html#a134f061d7883abbdb256abd48d53e66c">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a2267f74af554b8651d771ab7f453dc50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::startCaptureMultiThread </td>
          <td>(</td>
          <td class="paramtype">OnPfRingPacketsArriveCallback&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreMask&#160;</td>
          <td class="paramname"><em>coreMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start multi-threaded (multi-core) capturing with callback. Works with <a class="el" href="a00117.html#a923fa6c928456417a5985be210e3e487">openMultiRxChannels()</a>. This method will return an error if the number of opened channels is different than the number of threads/cores requested </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>A callback to call whenever a packet arrives </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>A cookie that will be delivered to onPacketsArrive callback on every packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreMask</td><td>The cores to be used as mask. For example: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2d15fc696287e4a5dc16bd809fdce893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::PfRingDevice::startCaptureSingleThread </td>
          <td>(</td>
          <td class="paramtype">OnPfRingPacketsArriveCallback&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start single-threaded capturing with callback. Works with <a class="el" href="a00117.html#a94f3512928cf7ccdb4f8a28532c6ee51">open()</a> or openSingleRxChannel(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>A callback to call whenever a packet arrives </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>A cookie that will be delivered to onPacketsArrive callback on every packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this action succeeds, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a31d086cb96e4e8de1e1d5ee640812575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::PfRingDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops capturing packets (works will all type of startCapture*) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00247.html">pcpp</a></li><li class="navelem"><a class="el" href="a00117.html">PfRingDevice</a></li>
    <li class="footer">Generated on Mon Feb 19 2018 10:09:20 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
