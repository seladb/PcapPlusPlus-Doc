<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: pcpp::DpdkDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00015.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00274.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::DpdkDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00198_source.html">DpdkDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::DpdkDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00015.png" usemap="#pcpp::DpdkDevice_map" alt=""/>
  <map id="pcpp::DpdkDevice_map" name="pcpp::DpdkDevice_map">
<area href="a00069.html" alt="pcpp::IPcapDevice" shape="rect" coords="0,0,118,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">DpdkDeviceConfiguration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">DpdkDeviceStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">LinkStatus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">RxTxStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28379431cb808e54444d17e692e10cff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a28379431cb808e54444d17e692e10cff">getDeviceId</a> ()</td></tr>
<tr class="separator:a28379431cb808e54444d17e692e10cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61a3bc39b4076528390401615340b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a8b61a3bc39b4076528390401615340b0">getDeviceName</a> ()</td></tr>
<tr class="separator:a8b61a3bc39b4076528390401615340b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6e40aef3710aca2fbf3b99fcab5029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00097.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a1a6e40aef3710aca2fbf3b99fcab5029">getMacAddress</a> ()</td></tr>
<tr class="separator:a1a6e40aef3710aca2fbf3b99fcab5029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6fe0ee2bff8d8aab767e8fd2fb7936"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a4e6fe0ee2bff8d8aab767e8fd2fb7936">getPMDName</a> ()</td></tr>
<tr class="separator:a4e6fe0ee2bff8d8aab767e8fd2fb7936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af783ec3a927bcdf098f604ffde385a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00253.html#adb43f1f8284d4e0b74d1c77b70152fa9">DpdkPMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#af783ec3a927bcdf098f604ffde385a4c">getPMDType</a> ()</td></tr>
<tr class="separator:af783ec3a927bcdf098f604ffde385a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed02181d03db521d72771a4b355bad63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00118.html">PciAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aed02181d03db521d72771a4b355bad63">getPciAddress</a> ()</td></tr>
<tr class="separator:aed02181d03db521d72771a4b355bad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4148c223d9f267c21b8ce30fe20310d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab4148c223d9f267c21b8ce30fe20310d">getMtu</a> ()</td></tr>
<tr class="separator:ab4148c223d9f267c21b8ce30fe20310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ab407d91e32668c844ed36b64fea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a9b3ab407d91e32668c844ed36b64fea2">setMtu</a> (uint16_t newMtu)</td></tr>
<tr class="separator:a9b3ab407d91e32668c844ed36b64fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a4321f24373e785cc07950a2434527"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac6a4321f24373e785cc07950a2434527">isVirtual</a> ()</td></tr>
<tr class="separator:ac6a4321f24373e785cc07950a2434527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca58304c0df036a23e40f1505925319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a4ca58304c0df036a23e40f1505925319">getLinkStatus</a> (<a class="el" href="a00094.html">LinkStatus</a> &amp;linkStatus)</td></tr>
<tr class="separator:a4ca58304c0df036a23e40f1505925319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e4e76fde88ccd4afe897bbf22c0b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5c3e4e76fde88ccd4afe897bbf22c0b4">getCurrentCoreId</a> ()</td></tr>
<tr class="separator:a5c3e4e76fde88ccd4afe897bbf22c0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9590ae9b2dd5ed3f978a602a3eadd5"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a9b9590ae9b2dd5ed3f978a602a3eadd5">getNumOfOpenedRxQueues</a> ()</td></tr>
<tr class="separator:a9b9590ae9b2dd5ed3f978a602a3eadd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab80b01d6068166d7fd0d4d5325e0630"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aab80b01d6068166d7fd0d4d5325e0630">getNumOfOpenedTxQueues</a> ()</td></tr>
<tr class="separator:aab80b01d6068166d7fd0d4d5325e0630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d6c3b4cba6b5eb427c6d2ac6ed7537"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae7d6c3b4cba6b5eb427c6d2ac6ed7537">getTotalNumOfRxQueues</a> ()</td></tr>
<tr class="separator:ae7d6c3b4cba6b5eb427c6d2ac6ed7537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cba8587e0770602c79f146bd98bb3b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a23cba8587e0770602c79f146bd98bb3b">getTotalNumOfTxQueues</a> ()</td></tr>
<tr class="separator:a23cba8587e0770602c79f146bd98bb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592be0165b16d968f44476601e95b60"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a6592be0165b16d968f44476601e95b60">receivePackets</a> (<a class="el" href="a00253.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;rawPacketsArr, uint16_t rxQueueId)</td></tr>
<tr class="separator:a6592be0165b16d968f44476601e95b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407145da015517eca651735bb7b318a9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a407145da015517eca651735bb7b318a9">receivePackets</a> (<a class="el" href="a00099.html">MBufRawPacket</a> **rawPacketsArr, uint16_t rawPacketArrLength, uint16_t rxQueueId)</td></tr>
<tr class="separator:a407145da015517eca651735bb7b318a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac062785f11bb19de2c0642354ca57f1c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ac062785f11bb19de2c0642354ca57f1c">receivePackets</a> (<a class="el" href="a00105.html">Packet</a> **packetsArr, uint16_t packetsArrLength, uint16_t rxQueueId)</td></tr>
<tr class="separator:ac062785f11bb19de2c0642354ca57f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab991ad2aba22f2c292386c48af1fad13"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab991ad2aba22f2c292386c48af1fad13">sendPackets</a> (<a class="el" href="a00099.html">MBufRawPacket</a> **rawPacketsArr, uint16_t arrLength, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:ab991ad2aba22f2c292386c48af1fad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7f3490db464e565322fcf04d1158f4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a6c7f3490db464e565322fcf04d1158f4">sendPackets</a> (<a class="el" href="a00105.html">Packet</a> **packetsArr, uint16_t arrLength, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:a6c7f3490db464e565322fcf04d1158f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e4d7263c65498601a434ab756eaa4b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a30e4d7263c65498601a434ab756eaa4b">sendPackets</a> (const <a class="el" href="a00253.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;rawPacketsVec, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:a30e4d7263c65498601a434ab756eaa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae468692ca0d522e53456c6f6670f86ab"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae468692ca0d522e53456c6f6670f86ab">sendPackets</a> (const <a class="el" href="a00253.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPacketsVec, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:ae468692ca0d522e53456c6f6670f86ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b528a8aa0b35ad2c0d02f856f5769c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aa1b528a8aa0b35ad2c0d02f856f5769c">sendPacket</a> (const <a class="el" href="a00132.html">RawPacket</a> &amp;rawPacket, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:aa1b528a8aa0b35ad2c0d02f856f5769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26b1061334d36862e99d090bf12e496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad26b1061334d36862e99d090bf12e496">sendPacket</a> (const <a class="el" href="a00099.html">MBufRawPacket</a> &amp;rawPacket, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:ad26b1061334d36862e99d090bf12e496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a3150918c9d1211523be9df288e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad87a3150918c9d1211523be9df288e93">sendPacket</a> (const <a class="el" href="a00105.html">Packet</a> &amp;packet, uint16_t txQueueId=0, bool useTxBuffer=false)</td></tr>
<tr class="separator:ad87a3150918c9d1211523be9df288e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b3bf26f2e77126c6ebc443600316e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a76b3bf26f2e77126c6ebc443600316e5">setFilter</a> (<a class="el" href="a00023.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:a76b3bf26f2e77126c6ebc443600316e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145dc440ebcd7c0a05709c57c2fa99d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a0145dc440ebcd7c0a05709c57c2fa99d">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a0145dc440ebcd7c0a05709c57c2fa99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae6116f6d0d7f515acb1c327fdcebbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues</a> (uint16_t numOfRxQueuesToOpen, uint16_t numOfTxQueuesToOpen, const <a class="el" href="a00016.html">DpdkDeviceConfiguration</a> &amp;config=<a class="el" href="a00016.html">DpdkDeviceConfiguration</a>())</td></tr>
<tr class="separator:afae6116f6d0d7f515acb1c327fdcebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200ae83e4eb63c66ff18a1004836f3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread</a> (<a class="el" href="a00253.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a> onPacketsArrive, void *onPacketsArriveUserCookie)</td></tr>
<tr class="separator:ae200ae83e4eb63c66ff18a1004836f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092dcc89b546b902698842fade374376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads</a> (<a class="el" href="a00253.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a> onPacketsArrive, void *onPacketsArriveUserCookie, CoreMask coreMask)</td></tr>
<tr class="separator:a092dcc89b546b902698842fade374376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3238998a22eb354c388d68d92285de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ae3238998a22eb354c388d68d92285de7">stopCapture</a> ()</td></tr>
<tr class="separator:ae3238998a22eb354c388d68d92285de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745ba46c5fbc633281c211e81cd4fea0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a745ba46c5fbc633281c211e81cd4fea0">getAmountOfFreeMbufs</a> ()</td></tr>
<tr class="separator:a745ba46c5fbc633281c211e81cd4fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24310ff4334d0defd3e46f144f7d987c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a24310ff4334d0defd3e46f144f7d987c">getAmountOfMbufsInUse</a> ()</td></tr>
<tr class="separator:a24310ff4334d0defd3e46f144f7d987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5717b8aa18dbb657e4c346adbb38163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ad5717b8aa18dbb657e4c346adbb38163">open</a> ()</td></tr>
<tr class="separator:ad5717b8aa18dbb657e4c346adbb38163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772ecb6a13f970a1671a143dfcf8edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#ab772ecb6a13f970a1671a143dfcf8edc">close</a> ()</td></tr>
<tr class="separator:ab772ecb6a13f970a1671a143dfcf8edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385533189ae3c86b503996d03b5e0d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a385533189ae3c86b503996d03b5e0d84">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a385533189ae3c86b503996d03b5e0d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5a81c3f794a32e8f11717db0db8c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a5a5a81c3f794a32e8f11717db0db8c54">getStatistics</a> (<a class="el" href="a00018.html">DpdkDeviceStats</a> &amp;stats)</td></tr>
<tr class="separator:a5a5a81c3f794a32e8f11717db0db8c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7a2351db1dc534a7cc8605af1046a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#a6d7a2351db1dc534a7cc8605af1046a1">clearStatistics</a> ()</td></tr>
<tr class="separator:a6d7a2351db1dc534a7cc8605af1046a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf80ebaaddb249744c657bd710193021"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html#aaf80ebaaddb249744c657bd710193021">flushTxBuffer</a> (bool flushOnlyIfTimeoutExpired=false, uint16_t txQueueId=0)</td></tr>
<tr class="separator:aaf80ebaaddb249744c657bd710193021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00069"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00069')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00069.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a22b03cdabb9f359c6bed0728c3614789">isOpened</a> ()</td></tr>
<tr class="separator:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aadba6a20265dca6ba29b548325a798fe">setFilter</a> (<a class="el" href="a00023.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aba28d535c6aa05e9f9492c82ece25de7">clearFilter</a> ()</td></tr>
<tr class="separator:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a00069"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00069')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a00069.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00069"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a5cc546829570cd981bfa762acd9759c8">verifyFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00069"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a54df47e98feadfd830789ca3a7f5f86b">matchPakcetWithFilter</a> (std::string filterAsString, <a class="el" href="a00132.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a DPDK port and enables receiving and sending packets using DPDK as well as getting interface info &amp; status, packet statistics, etc. This class has no public c'tor as it's constructed by <a class="el" href="a00017.html">DpdkDeviceList</a> during initialization.<br />
</p>
<p><b>RX/TX queues</b>: modern NICs provide hardware load-balancing for packets. This means that each packet received by the NIC is hashed by one or more parameter (IP address, port, etc.) and goes into one of several RX queues provided by the NIC. This enables applications to work in a multi-core environment where each core can read packets from different RX queue(s). Same goes for TX queues: it's possible to write packets to different TX queues and the NIC is taking care of sending them to the network. Different NICs provide different number of RX and TX queues. DPDK supports this capability and enables the user to open the DPDK port (<a class="el" href="a00015.html">DpdkDevice</a>) with a single or multiple RX and TX queues. When receiving packets the user can decide from which RX queue to read from, and when transmitting packets the user can decide to which TX queue to send them to. RX/TX queues are configured when opening the <a class="el" href="a00015.html">DpdkDevice</a> (see <a class="el" href="a00015.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a>)<br />
</p>
<p><b>Capturing packets</b>: there are two ways to capture packets using <a class="el" href="a00015.html">DpdkDevice</a>:</p><ul>
<li>using worker threads (see <a class="el" href="a00017.html#a6a2d2fdf700451adb9a27567f6e6eda3">DpdkDeviceList::startDpdkWorkerThreads()</a> ). When using this method the worker should use the <a class="el" href="a00015.html#a6592be0165b16d968f44476601e95b60">DpdkDevice::receivePackets()</a> methods to get packets from the <a class="el" href="a00015.html">DpdkDevice</a></li>
<li>by setting a callback which is invoked each time a burst of packets arrives. For more details see <a class="el" href="a00015.html#ae200ae83e4eb63c66ff18a1004836f3d">DpdkDevice::startCaptureSingleThread()</a></li>
</ul>
<p><b>Sending packets:</b> <a class="el" href="a00015.html">DpdkDevice</a> has various methods for sending packets. They enable sending raw packets, parsed packets, etc. for all opened TX queues. Also, DPDK provides an option to buffer TX packets and send them only when reaching a certain threshold (you can read more about it here: <a href="http://dpdk.org/doc/api/rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946">http://dpdk.org/doc/api/rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946</a>). <a class="el" href="a00015.html">DpdkDevice</a> supports that option as well. See <a class="el" href="a00015.html#ab991ad2aba22f2c292386c48af1fad13">DpdkDevice::sendPackets()</a><br />
</p>
<p><b>Get interface info</b>: <a class="el" href="a00015.html">DpdkDevice</a> provides all kind of information on the interface/device such as MAC address, MTU, link status, PCI address, PMD (poll-mode-driver) used for this port, etc. In addition it provides RX/TX statistics when receiving or sending packets<br />
</p>
<p><b>Known limitations:</b></p><ul>
<li>BPF filters are currently not supported by this device (as opposed to other PcapPlusPlus device types. This means that the device cannot filter packets before they get to the user</li>
<li>It's not possible to set or change NIC load-balancing method. DPDK provides this capability but it's still not supported by <a class="el" href="a00015.html">DpdkDevice</a> </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6d7a2351db1dc534a7cc8605af1046a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::clearStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear device statistics </p>

</div>
</div>
<a class="anchor" id="ab772ecb6a13f970a1671a143dfcf8edc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the <a class="el" href="a00015.html">DpdkDevice</a>. When device is closed it's not possible work with it </p>

<p>Implements <a class="el" href="a00069.html#a5ce8877d4e047f11a3cb8d0f4f527e56">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aaf80ebaaddb249744c657bd710193021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::flushTxBuffer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushOnlyIfTimeoutExpired</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DPDK supports an option to buffer TX packets and send them only when reaching a certain threshold. This method enables the user to flush a TX buffer for certain TX queue and send the packets stored in it (you can read about it here: <a href="http://dpdk.org/doc/api/rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946">http://dpdk.org/doc/api/rte__ethdev_8h.html#a0e941a74ae1b1b886764bc282458d946</a>). It has the option to flush only when timeout that was set in <a class="el" href="a00016.html#a225b415490ad496be6e0a93cf0b829ba">DpdkDeviceConfiguration::flushTxBufferTimeout</a> expired or flush immediately regardless of the timeout. The usage of this method can be in the main loop where you can call this method once every a couple of iterations to make sure TX buffers are flushed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flushOnlyIfTimeoutExpired</td><td>When set to true, flush will happen only if the timeout defined in <a class="el" href="a00016.html#a225b415490ad496be6e0a93cf0b829ba">DpdkDeviceConfiguration::flushTxBufferTimeout</a> expired. If set to false flush will happen immediately. Default value is false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>The TX queue ID to flush its buffer. Default is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent after buffer was flushed </dd></dl>

</div>
</div>
<a class="anchor" id="a745ba46c5fbc633281c211e81cd4fea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getAmountOfFreeMbufs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of free mbufs in device's mbufs pool </dd></dl>

</div>
</div>
<a class="anchor" id="a24310ff4334d0defd3e46f144f7d987c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getAmountOfMbufsInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of mbufs currently in use in device's mbufs pool </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3e4e76fde88ccd4afe897bbf22c0b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pcpp::DpdkDevice::getCurrentCoreId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The core ID used in this context </dd></dl>

</div>
</div>
<a class="anchor" id="a28379431cb808e54444d17e692e10cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device ID (DPDK port ID) </dd></dl>

</div>
</div>
<a class="anchor" id="a8b61a3bc39b4076528390401615340b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::DpdkDevice::getDeviceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device name which is in the format of 'DPDK_[PORT-ID]' </dd></dl>

</div>
</div>
<a class="anchor" id="a4ca58304c0df036a23e40f1505925319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::getLinkStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html">LinkStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>linkStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the link status (link up/down, link speed and link duplex) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linkStatus</td><td>A reference to object the result shall be written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a6e40aef3710aca2fbf3b99fcab5029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00097.html">MacAddress</a> pcpp::DpdkDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The MAC address of the device (DPDK port) </dd></dl>

</div>
</div>
<a class="anchor" id="ab4148c223d9f267c21b8ce30fe20310d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's maximum transmission unit (MTU) in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a9b9590ae9b2dd5ed3f978a602a3eadd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getNumOfOpenedRxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of RX queues currently opened for this device (as configured in <a class="el" href="a00015.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> ) </dd></dl>

</div>
</div>
<a class="anchor" id="aab80b01d6068166d7fd0d4d5325e0630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getNumOfOpenedTxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of TX queues currently opened for this device (as configured in <a class="el" href="a00015.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> ) </dd></dl>

</div>
</div>
<a class="anchor" id="aed02181d03db521d72771a4b355bad63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00118.html">PciAddress</a> pcpp::DpdkDevice::getPciAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The PCI address of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6fe0ee2bff8d8aab767e8fd2fb7936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::DpdkDevice::getPMDName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the PMD (poll mode driver) DPDK is using for this device. You can read about PMDs in the DPDK documentation: <a href="http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html">http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af783ec3a927bcdf098f604ffde385a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00253.html#adb43f1f8284d4e0b74d1c77b70152fa9">DpdkPMDType</a> pcpp::DpdkDevice::getPMDType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The enum type of the PMD (poll mode driver) DPDK is using for this device. You can read about PMDs in the DPDK documentation: <a href="http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html">http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a385533189ae3c86b503996d03b5e0d84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00257.html#_deprecated000001">Deprecated:</a></b></dt><dd>Please use <a class="el" href="a00015.html#a5a5a81c3f794a32e8f11717db0db8c54">DpdkDevice::getStatistics(DpdkDeviceStats&amp; stats)</a> instead </dd></dl>

<p>Implements <a class="el" href="a00069.html#ace3640f2330899687e34aa3789f4cd05">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a5a5a81c3f794a32e8f11717db0db8c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00018.html">DpdkDeviceStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve RX/TX statistics from device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A reference to a <a class="el" href="a00018.html">DpdkDeviceStats</a> object where stats will be written into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7d6c3b4cba6b5eb427c6d2ac6ed7537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getTotalNumOfRxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of RX queues available on this device </dd></dl>

</div>
</div>
<a class="anchor" id="a23cba8587e0770602c79f146bd98bb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getTotalNumOfTxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of TX queues available on this device </dd></dl>

</div>
</div>
<a class="anchor" id="ac6a4321f24373e785cc07950a2434527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::isVirtual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this device is a virtual interface (such as VMXNET3, 1G/10G virtual function, etc.), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad5717b8aa18dbb657e4c346adbb38163"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00069.html">IPcapDevice</a>. It calls <a class="el" href="a00015.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> with 1 RX queue and 1 TX queue. Notice opening the device only makes it ready to use, it doesn't start packet capturing. The device is opened in promiscuous mode </p><dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false if device is already opened, if RX/TX queues configuration failed or of DPDK port configuration and startup failed </dd></dl>

<p>Implements <a class="el" href="a00069.html#aa7d1358756653febf63d23b21447649c">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="afae6116f6d0d7f515acb1c327fdcebbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::openMultiQueues </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numOfRxQueuesToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numOfTxQueuesToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00016.html">DpdkDeviceConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="a00016.html">DpdkDeviceConfiguration</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the DPDK device. Notice opening the device only makes it ready to use, it doesn't start packet capturing. This method initializes RX and TX queues, configures the DPDK port and starts it. Call <a class="el" href="a00015.html#ab772ecb6a13f970a1671a143dfcf8edc">close()</a> to close the device. The device is opened in promiscuous mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfRxQueuesToOpen</td><td>Number of RX queues to setup. This number must be smaller or equal to the return value of <a class="el" href="a00015.html#ae7d6c3b4cba6b5eb427c6d2ac6ed7537">getTotalNumOfRxQueues()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfTxQueuesToOpen</td><td>Number of TX queues to setup. This number must be smaller or equal to the return value of <a class="el" href="a00015.html#a23cba8587e0770602c79f146bd98bb3b">getTotalNumOfTxQueues()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Optional parameter for defining special port configuration parameters such as number of receive/transmit descriptors. If not set the default parameters will be set (see <a class="el" href="a00016.html">DpdkDeviceConfiguration</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false if device is already opened, if RX/TX queues configuration failed or of DPDK port configuration and startup failed </dd></dl>

</div>
</div>
<a class="anchor" id="a6592be0165b16d968f44476601e95b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00253.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive raw packets from the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A vector where all received packets will be written into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a class="anchor" id="a407145da015517eca651735bb7b318a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00099.html">MBufRawPacket</a> **&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawPacketArrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive raw packets from the network. Please notice that in terms of performance, this is the best method to use for receiving packets because out of all receivePackets overloads this method requires the least overhead and is almost as efficient as receiving packets directly through DPDK. So if performance is a critical factor in your application, please use this method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A pointer to an array of <a class="el" href="a00099.html">MBufRawPacket</a> pointers where all received packets will be written into. The array is expected to be allocated by the user and its length should be provided in rawPacketArrLength. Number of packets received will be returned. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketArrLength</td><td>The length of <a class="el" href="a00099.html">MBufRawPacket</a> pointers array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a class="anchor" id="ac062785f11bb19de2c0642354ca57f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>packetsArrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive parsed packets from the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArr</td><td>A pointer to an allocated array of <a class="el" href="a00105.html">Packet</a> pointers where all received packets will be written into. The array is expected to be allocated by the user and its length should be provided in packetsArrLength. Number of packets received will be returned. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArrLength</td><td>The length of <a class="el" href="a00105.html">Packet</a> pointers array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets received. If an error occurred 0 will be returned and the error will be printed to log </dd></dl>

</div>
</div>
<a class="anchor" id="aa1b528a8aa0b35ad2c0d02f856f5769c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a raw packet to the network. Please notice that if the raw packet isn't of type <a class="el" href="a00099.html">MBufRawPacket</a>, a new temp <a class="el" href="a00099.html">MBufRawPacket</a> will be created and the data will be copied to it. This is necessary to allocate an mbuf which will store the data to be sent. If performance is a critical factor please make sure you send a raw packet of type <a class="el" href="a00099.html">MBufRawPacket</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The raw packet to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened, or if the packet wasn't sent for any other reason. Please notice that when using TX buffers the packet may be buffered and not sent immediately, which may also result in returning false </dd></dl>

</div>
</div>
<a class="anchor" id="ad26b1061334d36862e99d090bf12e496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00099.html">MBufRawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a <a class="el" href="a00099.html">MBufRawPacket</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The <a class="el" href="a00099.html">MBufRawPacket</a> to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened, or if the packet wasn't sent for any other reason. Please notice that when using TX buffers the packet may be buffered and not sent immediately, which may also result in returning false </dd></dl>

</div>
</div>
<a class="anchor" id="ad87a3150918c9d1211523be9df288e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00105.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a parsed packet to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The parsed packet to send. Please notice that if the packet contains a raw packet which isn't of type <a class="el" href="a00099.html">MBufRawPacket</a>, a new temp <a class="el" href="a00099.html">MBufRawPacket</a> will be created and the data will be copied to it. This is necessary to allocate an mbuf which will store the data to be sent. If performance is a critical factor please make sure you send a parsed packet that contains a raw packet of type <a class="el" href="a00099.html">MBufRawPacket</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent on. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened, or if the packet wasn't sent for any other reason. Please notice that when using TX buffers the packet may be buffered and not sent immediately, which may also result in returning false </dd></dl>

</div>
</div>
<a class="anchor" id="ab991ad2aba22f2c292386c48af1fad13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00099.html">MBufRawPacket</a> **&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="a00099.html">MBufRawPacket</a> to the network. Please notice the following:<br />
</p><ul>
<li>In terms of performance, this is the best method to use for sending packets because out of all sendPackets overloads this method requires the least overhead and is almost as efficient as sending the packets directly through DPDK. So if performance is a critical factor in your application, please use this method</li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>If the number of packets to send is higher than a threshold of 80% of total TX descriptors (which is typically around 400 packets), then after reaching this threshold there is a built-in 0.2 sec sleep to let the TX descriptors clean <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>A pointer to an array of <a class="el" href="a00099.html">MBufRawPacket</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent. If device is not opened or TX queue isn't open, 0 will be returned. Also, if TX buffer is being used and packets are buffered, some or all may not be actually sent </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a6c7f3490db464e565322fcf04d1158f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an array of parsed packets to the network. Please notice the following:<br />
</p><ul>
<li>If some or all of the packets contain raw packets which aren't of type <a class="el" href="a00099.html">MBufRawPacket</a>, a new temp <a class="el" href="a00099.html">MBufRawPacket</a> instances will be created and packet data will be copied to them. This is necessary to allocate mbufs which will store the data to be sent. If performance is a critical factor please make sure you send parsed packets that contain only raw packets of type <a class="el" href="a00099.html">MBufRawPacket</a></li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>If the number of packets to send is higher than a threshold of 80% of total TX descriptors (which is typically around 400 packets), then after reaching this threshold there is a built-in 0.2 sec sleep to let the TX descriptors clean <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>A pointer to an array of parsed packet pointers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent. If device is not opened or TX queue isn't open, 0 will be returned. Also, if TX buffer is being used and packets are buffered, some or all may not be actually sent </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a30e4d7263c65498601a434ab756eaa4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00253.html#a594cff22cd51c0a8acc36590c9733ecd">MBufRawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a vector of <a class="el" href="a00099.html">MBufRawPacket</a> pointers to the network. Please notice the following:<br />
</p><ul>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>If the number of packets to send is higher than a threshold of 80% of total TX descriptors (which is typically around 400 packets), then after reaching this threshold there is a built-in 0.2 sec sleep to let the TX descriptors clean <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsVec</td><td>The vector of raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent. If device is not opened or TX queue isn't open, 0 will be returned. Also, if TX buffer is being used and packets are buffered, some or all may not be actually sent </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ae468692ca0d522e53456c6f6670f86ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00253.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTxBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a vector of <a class="el" href="a00132.html">RawPacket</a> pointers to the network. Please notice the following:<br />
</p><ul>
<li>If some or all of the raw packets aren't of type <a class="el" href="a00099.html">MBufRawPacket</a>, a new temp <a class="el" href="a00099.html">MBufRawPacket</a> instances will be created and packet data will be copied to them. This is necessary to allocate mbufs which will store the data to be sent. If performance is a critical factor please make sure you send only raw packets of type <a class="el" href="a00099.html">MBufRawPacket</a> (or use the sendPackets overload that sends MBufRawPacketVector)</li>
<li>If the number of packets to send is higher than 64 this method will run multiple iterations of sending packets to DPDK, each iteration of 64 packets</li>
<li>If the number of packets to send is higher than a threshold of 80% of total TX descriptors (which is typically around 400 packets), then after reaching this threshold there is a built-in 0.2 sec sleep to let the TX descriptors clean <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsVec</td><td>The vector of raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useTxBuffer</td><td>A flag which indicates whether to use TX buffer mechanism or not. To read more about DPDK's TX buffer mechanism please refer to <a class="el" href="a00015.html">DpdkDevice</a> class description. Default value is false (don't use this mechanism) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually and successfully sent. If device is not opened or TX queue isn't open, 0 will be returned. Also, if TX buffer is being used and packets are buffered, some or all may not be actually sent </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a76b3bf26f2e77126c6ebc443600316e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00023.html">GeneralFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00069.html">IPcapDevice</a>. <b>BPF filters are currently not implemented for <a class="el" href="a00015.html">DpdkDevice</a></b> </p><dl class="section return"><dt>Returns</dt><dd>Always false with a "Filters aren't supported in DPDK device" error message </dd></dl>

</div>
</div>
<a class="anchor" id="a0145dc440ebcd7c0a05709c57c2fa99d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filterAsString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00069.html">IPcapDevice</a>. <b>BPF filters are currently not implemented for <a class="el" href="a00015.html">DpdkDevice</a></b> </p><dl class="section return"><dt>Returns</dt><dd>Always false with a "Filters aren't supported in DPDK device" error message </dd></dl>

<p>Reimplemented from <a class="el" href="a00069.html#a134f061d7883abbdb256abd48d53e66c">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9b3ab407d91e32668c844ed36b64fea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setMtu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newMtu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new maximum transmission unit (MTU) for this device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newMtu</td><td>The new MTU in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if MTU was set successfully, false if operation failed or if PMD doesn't support changing the MTU </dd></dl>

</div>
</div>
<a class="anchor" id="a092dcc89b546b902698842fade374376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::startCaptureMultiThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00253.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreMask&#160;</td>
          <td class="paramname"><em>coreMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method does exactly what <a class="el" href="a00015.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> does, but with more than one RX queue / capturing thread. It's called with a core mask as a parameter and creates a packet capture thread on every core. Each capturing thread is assigned with a specific RX queue. This method assumes all cores in the core-mask are available and there are enough opened RX queues to match for each thread. If these assumptions are not true an error is returned. After invoking all threads, all of them run in an endless loop and try to capture packets from their designated RX queues. Each time a burst of packets is captured the callback is invoked with the user cookie and the thread ID that captured the packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>The user callback which will be invoked each time a burst of packets is captured by the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>The user callback is invoked with this cookie as a parameter. It can be used to pass information from the user application to the callback </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">coreMask</td><td>The core-mask for creating the cpature threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all capture threads started successfully or false if device is already in capture mode, not all cores in the core-mask are available to DPDK, there are not enough opened RX queues to match all cores in the core-mask, or if thread invocation failed. In all of these cases an appropriate error message will be printed </dd></dl>

</div>
</div>
<a class="anchor" id="ae200ae83e4eb63c66ff18a1004836f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::startCaptureSingleThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00253.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are two ways to capture packets using <a class="el" href="a00015.html">DpdkDevice</a>: one of them is using worker threads (see <a class="el" href="a00017.html#a6a2d2fdf700451adb9a27567f6e6eda3">DpdkDeviceList::startDpdkWorkerThreads()</a> ) and the other way is setting a callback which is invoked each time a burst of packets is captured. This method implements the second way. After invoking this method the <a class="el" href="a00015.html">DpdkDevice</a> enters capture mode and starts capturing packets. This method assumes there is only 1 RX queue opened for this device, otherwise an error is returned. It then allocates a core and creates 1 thread that runs in an endless loop and tries to capture packets using DPDK. Each time a burst of packets is captured the user callback is invoked with the user cookie as a parameter. This loop continues until <a class="el" href="a00015.html#ae3238998a22eb354c388d68d92285de7">stopCapture()</a> is called. Notice: since the callback is invoked for every packet burst using this method can be slower than using worker threads. On the other hand, it's a simpler way comparing to worker threads </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>The user callback which will be invoked each time a packet burst is captured by the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>The user callback is invoked with this cookie as a parameter. It can be used to pass information from the user application to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture thread started successfully or false if device is already in capture mode, number of opened RX queues isn't equal to 1, if the method couldn't find an available core to allocate for the capture thread, or if thread invocation failed. In all of these cases an appropriate error message will be printed </dd></dl>

</div>
</div>
<a class="anchor" id="ae3238998a22eb354c388d68d92285de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If device is in capture mode started by invoking <a class="el" href="a00015.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> or <a class="el" href="a00015.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads()</a>, this method will stop all capturing threads and set the device to non-capturing mode </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00253.html">pcpp</a></li><li class="navelem"><a class="el" href="a00015.html">DpdkDevice</a></li>
    <li class="footer">Generated on Fri Apr 13 2018 01:38:32 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
