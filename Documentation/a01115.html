<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01115.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a01112.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::Packet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00071_source.html">Packet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a1a6d4e157661ba7ec6f552c78c82d7fa">Packet</a> (size_t maxPacketLen=1)</td></tr>
<tr class="separator:a1a6d4e157661ba7ec6f552c78c82d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61c3f9a5c12a7047774b42f31ee2ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#aaf61c3f9a5c12a7047774b42f31ee2ec">Packet</a> (<a class="el" href="a01295.html">RawPacket</a> *rawPacket, bool freeRawPacket=false, <a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:aaf61c3f9a5c12a7047774b42f31ee2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b12034dca53509c273e4ef954b8099"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#aa9b12034dca53509c273e4ef954b8099">Packet</a> (<a class="el" href="a01295.html">RawPacket</a> *rawPacket, <a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil)</td></tr>
<tr class="separator:aa9b12034dca53509c273e4ef954b8099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af7caebc8d97ac92910d8a91186b461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a9af7caebc8d97ac92910d8a91186b461">Packet</a> (<a class="el" href="a01295.html">RawPacket</a> *rawPacket, <a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer)</td></tr>
<tr class="separator:a9af7caebc8d97ac92910d8a91186b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a54ccf8336cf3c3f6a5ad58ad12f06656">~Packet</a> ()</td></tr>
<tr class="separator:a54ccf8336cf3c3f6a5ad58ad12f06656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d603615d2f100eec547d51b4a6282e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a11d603615d2f100eec547d51b4a6282e">Packet</a> (const <a class="el" href="a01115.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a11d603615d2f100eec547d51b4a6282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af180628893e454e9d6e0f2f1ebb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01115.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a26af180628893e454e9d6e0f2f1ebb98">operator=</a> (const <a class="el" href="a01115.html">Packet</a> &amp;other)</td></tr>
<tr class="separator:a26af180628893e454e9d6e0f2f1ebb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7727ee05d4dc422ebe74c58ddd11cb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a7727ee05d4dc422ebe74c58ddd11cb22">getRawPacket</a> ()</td></tr>
<tr class="separator:a7727ee05d4dc422ebe74c58ddd11cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dee26fe9bb8c7ae6cd90f45e67446ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a1dee26fe9bb8c7ae6cd90f45e67446ef">setRawPacket</a> (<a class="el" href="a01295.html">RawPacket</a> *rawPacket, bool freeRawPacket, <a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> parseUntil=<a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a>, <a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a> parseUntilLayer=<a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a>)</td></tr>
<tr class="separator:a1dee26fe9bb8c7ae6cd90f45e67446ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fede8a4bee643ee85bfbc4ddd7174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a1c4fede8a4bee643ee85bfbc4ddd7174">getRawPacketReadOnly</a> () const</td></tr>
<tr class="separator:a1c4fede8a4bee643ee85bfbc4ddd7174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f98bcdd465eac96673752838826de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01083.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a02f98bcdd465eac96673752838826de4">getFirstLayer</a> ()</td></tr>
<tr class="separator:a02f98bcdd465eac96673752838826de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2dd7a761efe7393249ddc54bdd662b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01083.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a1c2dd7a761efe7393249ddc54bdd662b">getLastLayer</a> ()</td></tr>
<tr class="separator:a1c2dd7a761efe7393249ddc54bdd662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c12806f2b320cdddd83a2b3a1136eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer</a> (<a class="el" href="a01083.html">Layer</a> *newLayer)</td></tr>
<tr class="separator:af4c12806f2b320cdddd83a2b3a1136eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f9ea31fb1b7fa610db251405522f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer</a> (<a class="el" href="a01083.html">Layer</a> *prevLayer, <a class="el" href="a01083.html">Layer</a> *newLayer)</td></tr>
<tr class="separator:a2e2f9ea31fb1b7fa610db251405522f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab751fc35d7e7b8a86e3f1fdbd2c30685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#ab751fc35d7e7b8a86e3f1fdbd2c30685">removeLayer</a> (<a class="el" href="a01083.html">Layer</a> *layer)</td></tr>
<tr class="separator:ab751fc35d7e7b8a86e3f1fdbd2c30685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d0de95b49eb313e3184021234e5c5e"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:a78d0de95b49eb313e3184021234e5c5e"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01115.html#a78d0de95b49eb313e3184021234e5c5e">getLayerOfType</a> ()</td></tr>
<tr class="separator:a78d0de95b49eb313e3184021234e5c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d545bb4bc80e5d45858c373b20befa9"><td class="memTemplParams" colspan="2">template&lt;class TLayer &gt; </td></tr>
<tr class="memitem:a1d545bb4bc80e5d45858c373b20befa9"><td class="memTemplItemLeft" align="right" valign="top">TLayer *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01115.html#a1d545bb4bc80e5d45858c373b20befa9">getNextLayerOfType</a> (<a class="el" href="a01083.html">Layer</a> *after)</td></tr>
<tr class="separator:a1d545bb4bc80e5d45858c373b20befa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b12946df5f2e6077e32620389a3c32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a90b12946df5f2e6077e32620389a3c32">isPacketOfType</a> (<a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a> protocolType)</td></tr>
<tr class="separator:a90b12946df5f2e6077e32620389a3c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19addb15ea46927076227436fde753e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#ab19addb15ea46927076227436fde753e">computeCalculateFields</a> ()</td></tr>
<tr class="separator:ab19addb15ea46927076227436fde753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a62bbd020dc2e88147be71876a758"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a8c3a62bbd020dc2e88147be71876a758">toString</a> (bool timeAsLocalTime=true)</td></tr>
<tr class="separator:a8c3a62bbd020dc2e88147be71876a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e568de8d974fc34d7a7ced0c40e030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html#a14e568de8d974fc34d7a7ced0c40e030">toStringList</a> (std::vector&lt; std::string &gt; &amp;result, bool timeAsLocalTime=true)</td></tr>
<tr class="separator:a14e568de8d974fc34d7a7ced0c40e030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a parsed packet. It contains the raw data (<a class="el" href="a01295.html">RawPacket</a> instance), and a linked list of layers, each layer is a parsed protocol that this packet contains. The layers linked list is ordered where the first layer is the lowest in the packet (currently it's always Ethernet protocol as PcapPlusPlus supports only Ethernet packets), the next layer will be L2.5 or L3 (e.g VLAN, IPv4, IPv6, etc.), and so on. etc.), etc. The last layer in the linked list will be the highest in the packet. For example: for a standard HTTP request packet the layer will look like this: <a class="el" href="a00811.html">EthLayer</a> -&gt; <a class="el" href="a01015.html">IPv4Layer</a> -&gt; <a class="el" href="a01479.html">TcpLayer</a> -&gt; <a class="el" href="a00847.html">HttpRequestLayer</a> <br />
 <a class="el" href="a01115.html">Packet</a> instance isn't read only. The user can add or remove layers, update current layer, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a6d4e157661ba7ec6f552c78c82d7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6d4e157661ba7ec6f552c78c82d7fa">&#9670;&nbsp;</a></span>Packet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPacketLen</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a new packet. Very useful when creating packets. When using this constructor an empty raw buffer is allocated (with the size of maxPacketLen) and a new <a class="el" href="a01295.html">RawPacket</a> is created </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPacketLen</td><td>The expected packet length in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf61c3f9a5c12a7047774b42f31ee2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf61c3f9a5c12a7047774b42f31ee2ec">&#9670;&nbsp;</a></span>Packet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="a01295.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="a01295.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="a01295.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="a01115.html">Packet</a> is free or not </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>Optional parameter. A flag indicating if the destructor should also call the raw packet destructor or not. Default value is false </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the packet until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the packet until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b12034dca53509c273e4ef954b8099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b12034dca53509c273e4ef954b8099">&#9670;&nbsp;</a></span>Packet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="a01295.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="a01295.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="a01295.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="a01115.html">Packet</a> is free or not. This constructor should be used to parse the packet up to a certain layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Optional parameter. Parse the packet until you reach a certain protocol (inclusive). Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af7caebc8d97ac92910d8a91186b461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af7caebc8d97ac92910d8a91186b461">&#9670;&nbsp;</a></span>Packet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor for creating a packet out of already allocated <a class="el" href="a01295.html">RawPacket</a>. Very useful when parsing packets that came from the network. When using this constructor a pointer to the <a class="el" href="a01295.html">RawPacket</a> is saved (data isn't copied) and the <a class="el" href="a01295.html">RawPacket</a> is parsed, meaning all layers are created and linked to each other in the right order. In this overload of the constructor the user can specify whether to free the instance of raw packet when the <a class="el" href="a01115.html">Packet</a> is free or not. . This constructor should be used to parse the packet up to a certain layer in the OSI model </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A pointer to the raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Optional parameter. Parse the packet until you reach a certain layer in the OSI model (inclusive). Can be useful for cases when you need to parse only up to a certain OSI layer (for example transport layer) and want to avoid the performance impact and memory consumption of parsing the whole packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54ccf8336cf3c3f6a5ad58ad12f06656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ccf8336cf3c3f6a5ad58ad12f06656">&#9670;&nbsp;</a></span>~Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pcpp::Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A destructor for this class. Frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="a01115.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer()</a> or <a class="el" href="a01115.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor) </p>

</div>
</div>
<a id="a11d603615d2f100eec547d51b4a6282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d603615d2f100eec547d51b4a6282e">&#9670;&nbsp;</a></span>Packet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcpp::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01115.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor for this class. This copy constructor copies all the raw data and re-create all layers. So when the original <a class="el" href="a01115.html">Packet</a> is being freed, no data will be lost in the copied instance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af4c12806f2b320cdddd83a2b3a1136eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c12806f2b320cdddd83a2b3a1136eb">&#9670;&nbsp;</a></span>addLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::addLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01083.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new layer as the last layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="ab19addb15ea46927076227436fde753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19addb15ea46927076227436fde753e">&#9670;&nbsp;</a></span>computeCalculateFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::computeCalculateFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can have fields that can be calculate automatically from other fields using <a class="el" href="a01083.html#abea112176d18e896f48214ca7accac71">Layer::computeCalculateFields()</a>. This method forces all layers to calculate these fields values </p>

</div>
</div>
<a id="a02f98bcdd465eac96673752838826de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f98bcdd465eac96673752838826de4">&#9670;&nbsp;</a></span>getFirstLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01083.html">Layer</a>* pcpp::Packet::getFirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the first (lowest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the first (lowest) layer in the packet </dd></dl>

</div>
</div>
<a id="a1c2dd7a761efe7393249ddc54bdd662b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2dd7a761efe7393249ddc54bdd662b">&#9670;&nbsp;</a></span>getLastLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01083.html">Layer</a>* pcpp::Packet::getLastLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the last (highest) layer in the packet </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the last (highest) layer in the packet </dd></dl>

</div>
</div>
<a id="a78d0de95b49eb313e3184021234e5c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d0de95b49eb313e3184021234e5c5e">&#9670;&nbsp;</a></span>getLayerOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getLayerOfType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get a layer of a certain type (protocol). If no layer of such type is found, NULL is returned </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a id="a1d545bb4bc80e5d45858c373b20befa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d545bb4bc80e5d45858c373b20befa9">&#9670;&nbsp;</a></span>getNextLayerOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TLayer * pcpp::Packet::getNextLayerOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01083.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>after</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A templated method to get the first layer of a certain type (protocol), start searching from a certain layer. For example: if a packet looks like: <a class="el" href="a00811.html">EthLayer</a> -&gt; VlanLayer(1) -&gt; VlanLayer(2) -&gt; VlanLayer(3) -&gt; <a class="el" href="a01015.html">IPv4Layer</a> and the user put VlanLayer(2) as a parameter and wishes to search for a <a class="el" href="a01527.html">VlanLayer</a>, VlanLayer(3) will be returned If no layer of such type is found, NULL is returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">after</td><td>A pointer to the layer to start search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer of the requested type, NULL if not found </dd></dl>

</div>
</div>
<a id="a7727ee05d4dc422ebe74c58ddd11cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7727ee05d4dc422ebe74c58ddd11cb22">&#9670;&nbsp;</a></span>getRawPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01295.html">RawPacket</a>* pcpp::Packet::getRawPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="a01115.html">Packet</a>'s <a class="el" href="a01295.html">RawPacket</a> </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="a01115.html">Packet</a>'s <a class="el" href="a01295.html">RawPacket</a> </dd></dl>

</div>
</div>
<a id="a1c4fede8a4bee643ee85bfbc4ddd7174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4fede8a4bee643ee85bfbc4ddd7174">&#9670;&nbsp;</a></span>getRawPacketReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01295.html">RawPacket</a>* pcpp::Packet::getRawPacketReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the <a class="el" href="a01115.html">Packet</a>'s <a class="el" href="a01295.html">RawPacket</a> in a read-only manner </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="a01115.html">Packet</a>'s <a class="el" href="a01295.html">RawPacket</a> </dd></dl>

</div>
</div>
<a id="a2e2f9ea31fb1b7fa610db251405522f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f9ea31fb1b7fa610db251405522f7">&#9670;&nbsp;</a></span>insertLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::insertLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01083.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>prevLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01083.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>newLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new layer after an existing layer in the packet. This method gets a pointer to the new layer as a parameter and attaches it to the packet. Notice after calling this method the input layer is attached to the packet so every change you make in it affect the packet; Also it cannot be attached to other packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prevLayer</td><td>A pointer to an existing layer in the packet which the new layer should followed by. If this layer isn't attached to a packet and error will be printed to log and false will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newLayer</td><td>A pointer to the new layer to be added to the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="a90b12946df5f2e6077e32620389a3c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b12946df5f2e6077e32620389a3c32">&#9670;&nbsp;</a></span>isPacketOfType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::isPacketOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocolType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the packet contains a certain protocol </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocolType</td><td>The protocol type to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet contains the protocol, false otherwise </dd></dl>

</div>
</div>
<a id="a26af180628893e454e9d6e0f2f1ebb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26af180628893e454e9d6e0f2f1ebb98">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01115.html">Packet</a>&amp; pcpp::Packet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01115.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator overloading. It first frees all layers allocated by this instance (Notice: it doesn't free layers that weren't allocated by this class, for example layers that were added by <a class="el" href="a01115.html#af4c12806f2b320cdddd83a2b3a1136eb">addLayer()</a> or <a class="el" href="a01115.html#a2e2f9ea31fb1b7fa610db251405522f7">insertLayer()</a> ). In addition it frees the raw packet if it was allocated by this instance (meaning if it was allocated by this instance constructor). Afterwards it copies the data from the other packet in the same way used in the copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab751fc35d7e7b8a86e3f1fdbd2c30685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab751fc35d7e7b8a86e3f1fdbd2c30685">&#9670;&nbsp;</a></span>removeLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::Packet::removeLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01083.html">Layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an existing layer from the packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>The layer to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything went well or false otherwise (an appropriate error log message will be printed in such cases) </dd></dl>

</div>
</div>
<a id="a1dee26fe9bb8c7ae6cd90f45e67446ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dee26fe9bb8c7ae6cd90f45e67446ef">&#9670;&nbsp;</a></span>setRawPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::setRawPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01295.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeRawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eb">ProtocolType</a>&#160;</td>
          <td class="paramname"><em>parseUntil</em> = <code><a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025">OsiModelLayer</a>&#160;</td>
          <td class="paramname"><em>parseUntilLayer</em> = <code><a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a <a class="el" href="a01295.html">RawPacket</a> and re-construct all packet layers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>Raw packet to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeRawPacket</td><td>A flag indicating if the destructor should also call the raw packet destructor or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntil</td><td>Parse the packet until it reaches this protocol. Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="a00179.html#a1d761f7cf37d3b1efb1574fb1177e6eba8576597b751111eab8ec156233a7fd29">UnknownProtocol</a> which means don't take this parameter into account </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parseUntilLayer</td><td>Parse the packet until certain layer in OSI model. Can be useful for cases when you need to parse only up to a certain layer and want to avoid the performance impact and memory consumption of parsing the whole packet. Default value is <a class="el" href="a00179.html#a69e2ee6a9dc68797612cf8dc38461025aaa1b22ad907997f669b20cc0d3b7e87f">OsiModelLayerUnknown</a> which means don't take this parameter into account </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c3a62bbd020dc2e88147be71876a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3a62bbd020dc2e88147be71876a758">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::Packet::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeAsLocalTime</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each layer can print a string representation of the layer most important data using <a class="el" href="a01083.html#a3acb12ad2f7e10ed03fc3dd0ae22dbf7">Layer::toString()</a>. This method aggregates this string from all layers and print it to a complete string containing all packet's relevant data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeAsLocalTime</td><td>Print time as local time or GMT. Default (true value) is local time, for GMT set to false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing most relevant data from all layers (looks like the packet description in Wireshark) </dd></dl>

</div>
</div>
<a id="a14e568de8d974fc34d7a7ced0c40e030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e568de8d974fc34d7a7ced0c40e030">&#9670;&nbsp;</a></span>toStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::Packet::toStringList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeAsLocalTime</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="a01115.html#a8c3a62bbd020dc2e88147be71876a758">toString()</a>, but instead of one string it outputs a list of strings, one string for every layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>A string vector that will contain all strings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeAsLocalTime</td><td>Print time as local time or GMT. Default (true value) is local time, for GMT set to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00179.html">pcpp</a></li><li class="navelem"><a class="el" href="a01115.html">Packet</a></li>
    <li class="footer">Generated on Tue Aug 21 2018 22:39:31 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
