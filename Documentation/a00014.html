<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: pcpp::DpdkDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00014.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00215.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::DpdkDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00153_source.html">DpdkDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::DpdkDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00014.png" usemap="#pcpp::DpdkDevice_map" alt=""/>
  <map id="pcpp::DpdkDevice_map" name="pcpp::DpdkDevice_map">
<area href="a00057.html" alt="pcpp::IPcapDevice" shape="rect" coords="0,0,118,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">DpdkDeviceConfiguration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">LinkStatus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28379431cb808e54444d17e692e10cff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a28379431cb808e54444d17e692e10cff">getDeviceId</a> ()</td></tr>
<tr class="separator:a28379431cb808e54444d17e692e10cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61a3bc39b4076528390401615340b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a8b61a3bc39b4076528390401615340b0">getDeviceName</a> ()</td></tr>
<tr class="separator:a8b61a3bc39b4076528390401615340b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6e40aef3710aca2fbf3b99fcab5029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a1a6e40aef3710aca2fbf3b99fcab5029">getMacAddress</a> ()</td></tr>
<tr class="separator:a1a6e40aef3710aca2fbf3b99fcab5029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6fe0ee2bff8d8aab767e8fd2fb7936"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a4e6fe0ee2bff8d8aab767e8fd2fb7936">getPMDName</a> ()</td></tr>
<tr class="separator:a4e6fe0ee2bff8d8aab767e8fd2fb7936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af783ec3a927bcdf098f604ffde385a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00197.html#adb43f1f8284d4e0b74d1c77b70152fa9">DpdkPMDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#af783ec3a927bcdf098f604ffde385a4c">getPMDType</a> ()</td></tr>
<tr class="separator:af783ec3a927bcdf098f604ffde385a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed02181d03db521d72771a4b355bad63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00089.html">PciAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#aed02181d03db521d72771a4b355bad63">getPciAddress</a> ()</td></tr>
<tr class="separator:aed02181d03db521d72771a4b355bad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4148c223d9f267c21b8ce30fe20310d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ab4148c223d9f267c21b8ce30fe20310d">getMtu</a> ()</td></tr>
<tr class="separator:ab4148c223d9f267c21b8ce30fe20310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ab407d91e32668c844ed36b64fea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a9b3ab407d91e32668c844ed36b64fea2">setMtu</a> (uint16_t newMtu)</td></tr>
<tr class="separator:a9b3ab407d91e32668c844ed36b64fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a4321f24373e785cc07950a2434527"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ac6a4321f24373e785cc07950a2434527">isVirtual</a> ()</td></tr>
<tr class="separator:ac6a4321f24373e785cc07950a2434527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca58304c0df036a23e40f1505925319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a4ca58304c0df036a23e40f1505925319">getLinkStatus</a> (<a class="el" href="a00067.html">LinkStatus</a> &amp;linkStatus)</td></tr>
<tr class="separator:a4ca58304c0df036a23e40f1505925319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e4e76fde88ccd4afe897bbf22c0b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a5c3e4e76fde88ccd4afe897bbf22c0b4">getCurrentCoreId</a> ()</td></tr>
<tr class="separator:a5c3e4e76fde88ccd4afe897bbf22c0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9590ae9b2dd5ed3f978a602a3eadd5"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a9b9590ae9b2dd5ed3f978a602a3eadd5">getNumOfOpenedRxQueues</a> ()</td></tr>
<tr class="separator:a9b9590ae9b2dd5ed3f978a602a3eadd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab80b01d6068166d7fd0d4d5325e0630"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#aab80b01d6068166d7fd0d4d5325e0630">getNumOfOpenedTxQueues</a> ()</td></tr>
<tr class="separator:aab80b01d6068166d7fd0d4d5325e0630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d6c3b4cba6b5eb427c6d2ac6ed7537"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ae7d6c3b4cba6b5eb427c6d2ac6ed7537">getTotalNumOfRxQueues</a> ()</td></tr>
<tr class="separator:ae7d6c3b4cba6b5eb427c6d2ac6ed7537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cba8587e0770602c79f146bd98bb3b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a23cba8587e0770602c79f146bd98bb3b">getTotalNumOfTxQueues</a> ()</td></tr>
<tr class="separator:a23cba8587e0770602c79f146bd98bb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1459cfd1875c5033398a1ac7c00f3394"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a1459cfd1875c5033398a1ac7c00f3394">receivePackets</a> (<a class="el" href="a00197.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPacketsArr, uint16_t rxQueueId)</td></tr>
<tr class="separator:a1459cfd1875c5033398a1ac7c00f3394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8dc9d0c67e4d5c1d55f4a32e2e7c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a8b8dc9d0c67e4d5c1d55f4a32e2e7c6c">receivePackets</a> (<a class="el" href="a00072.html">MBufRawPacket</a> **rawPacketsArr, int &amp;rawPacketArrLength, uint16_t rxQueueId)</td></tr>
<tr class="separator:a8b8dc9d0c67e4d5c1d55f4a32e2e7c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9a34cc0c4144dbbfa567747ebedef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a4c9a34cc0c4144dbbfa567747ebedef2">receivePackets</a> (<a class="el" href="a00078.html">Packet</a> **packetsArr, int &amp;packetsArrLength, uint16_t rxQueueId)</td></tr>
<tr class="separator:a4c9a34cc0c4144dbbfa567747ebedef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e69fcb1444764603d3238b53bb0b8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets</a> (const <a class="el" href="a00103.html">RawPacket</a> *rawPacketsArr, int arrLength, uint16_t txQueueId=0)</td></tr>
<tr class="separator:a09e69fcb1444764603d3238b53bb0b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fab081e84cefcbbe7980f1a294aa81a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a9fab081e84cefcbbe7980f1a294aa81a">sendPackets</a> (const <a class="el" href="a00078.html">Packet</a> **packetsArr, int arrLength, uint16_t txQueueId=0)</td></tr>
<tr class="separator:a9fab081e84cefcbbe7980f1a294aa81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad779de9154a16454e2075441a4046251"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ad779de9154a16454e2075441a4046251">sendPackets</a> (const <a class="el" href="a00197.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPacketsVec, uint16_t txQueueId=0)</td></tr>
<tr class="separator:ad779de9154a16454e2075441a4046251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b57e22a8ecf001ea2ca9dbd023d277"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a80b57e22a8ecf001ea2ca9dbd023d277">sendPacket</a> (const uint8_t *packetData, int packetDataLength, uint16_t txQueueId=0)</td></tr>
<tr class="separator:a80b57e22a8ecf001ea2ca9dbd023d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced19469d7bb32b147d1a7aadbe4aa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#aced19469d7bb32b147d1a7aadbe4aa37">sendPacket</a> (const <a class="el" href="a00103.html">RawPacket</a> &amp;rawPacket, uint16_t txQueueId=0)</td></tr>
<tr class="separator:aced19469d7bb32b147d1a7aadbe4aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed37d14a7ef70e31fd88510d49ca9c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a6ed37d14a7ef70e31fd88510d49ca9c6">sendPacket</a> (const <a class="el" href="a00078.html">Packet</a> &amp;packet, uint16_t txQueueId=0)</td></tr>
<tr class="separator:a6ed37d14a7ef70e31fd88510d49ca9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b3bf26f2e77126c6ebc443600316e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a76b3bf26f2e77126c6ebc443600316e5">setFilter</a> (<a class="el" href="a00021.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:a76b3bf26f2e77126c6ebc443600316e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145dc440ebcd7c0a05709c57c2fa99d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a0145dc440ebcd7c0a05709c57c2fa99d">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a0145dc440ebcd7c0a05709c57c2fa99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae6116f6d0d7f515acb1c327fdcebbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues</a> (uint16_t numOfRxQueuesToOpen, uint16_t numOfTxQueuesToOpen, const <a class="el" href="a00015.html">DpdkDeviceConfiguration</a> &amp;config=<a class="el" href="a00015.html">DpdkDeviceConfiguration</a>())</td></tr>
<tr class="separator:afae6116f6d0d7f515acb1c327fdcebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200ae83e4eb63c66ff18a1004836f3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread</a> (<a class="el" href="a00197.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a> onPacketsArrive, void *onPacketsArriveUserCookie)</td></tr>
<tr class="separator:ae200ae83e4eb63c66ff18a1004836f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092dcc89b546b902698842fade374376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads</a> (<a class="el" href="a00197.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a> onPacketsArrive, void *onPacketsArriveUserCookie, CoreMask coreMask)</td></tr>
<tr class="separator:a092dcc89b546b902698842fade374376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3238998a22eb354c388d68d92285de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ae3238998a22eb354c388d68d92285de7">stopCapture</a> ()</td></tr>
<tr class="separator:ae3238998a22eb354c388d68d92285de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745ba46c5fbc633281c211e81cd4fea0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a745ba46c5fbc633281c211e81cd4fea0">getAmountOfFreeMbufs</a> ()</td></tr>
<tr class="separator:a745ba46c5fbc633281c211e81cd4fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24310ff4334d0defd3e46f144f7d987c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a24310ff4334d0defd3e46f144f7d987c">getAmountOfMbufsInUse</a> ()</td></tr>
<tr class="separator:a24310ff4334d0defd3e46f144f7d987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5717b8aa18dbb657e4c346adbb38163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ad5717b8aa18dbb657e4c346adbb38163">open</a> ()</td></tr>
<tr class="separator:ad5717b8aa18dbb657e4c346adbb38163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772ecb6a13f970a1671a143dfcf8edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ab772ecb6a13f970a1671a143dfcf8edc">close</a> ()</td></tr>
<tr class="separator:ab772ecb6a13f970a1671a143dfcf8edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385533189ae3c86b503996d03b5e0d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a385533189ae3c86b503996d03b5e0d84">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a385533189ae3c86b503996d03b5e0d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00057"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00057')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00057.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a22b03cdabb9f359c6bed0728c3614789">isOpened</a> ()</td></tr>
<tr class="separator:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#aadba6a20265dca6ba29b548325a798fe">setFilter</a> (<a class="el" href="a00021.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33400a37378ceb807228c43efbff47e inherit pub_methods_a00057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#aa33400a37378ceb807228c43efbff47e">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:aa33400a37378ceb807228c43efbff47e inherit pub_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#aba28d535c6aa05e9f9492c82ece25de7">clearFilter</a> ()</td></tr>
<tr class="separator:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a00057"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00057')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a00057.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00057"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a5cc546829570cd981bfa762acd9759c8">verifyFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00057"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a54df47e98feadfd830789ca3a7f5f86b">matchPakcetWithFilter</a> (std::string filterAsString, <a class="el" href="a00103.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a00057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a DPDK port and enables receiving and sending packets using DPDK as well as getting interface info &amp; status, packet statistics, etc. This class has no public c'tor as it's constructed by <a class="el" href="a00016.html">DpdkDeviceList</a> during initialization.<br />
</p>
<p><b>RX/TX queues</b>: modern NICs provide hardware load-balancing for packets. This means that each packet received by the NIC is hashed by one or more parameter (IP address, port, etc.) and goes into one of several RX queues provided by the NIC. This enables applications to work in a multi-core environment where each core can read packets from different RX queue(s). Same goes for TX queues: it's possible to write packets to different TX queues and the NIC is taking care of sending them to the network. Different NICs provide different number of RX and TX queues. DPDK supports this capability and enables the user to open the DPDK port (<a class="el" href="a00014.html">DpdkDevice</a>) with a single or multiple RX and TX queues. When receiving packets the user can decide from which RX queue to read from, and when transmitting packets the user can decide to which TX queue to send them to. RX/TX queues are configured when opening the <a class="el" href="a00014.html">DpdkDevice</a> (see <a class="el" href="a00014.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a>)<br />
</p>
<p><b>Capturing packets</b>: there are two ways to capture packets using <a class="el" href="a00014.html">DpdkDevice</a>:</p><ul>
<li>using worker threads (see <a class="el" href="a00016.html#a6a2d2fdf700451adb9a27567f6e6eda3">DpdkDeviceList::startDpdkWorkerThreads()</a> ). When using this method the worker should use the <a class="el" href="a00014.html#a1459cfd1875c5033398a1ac7c00f3394">DpdkDevice::receivePackets()</a> methods to get packets from the <a class="el" href="a00014.html">DpdkDevice</a></li>
<li>by setting a callback which is invoked each time a burst of packets arrives. For more details see <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">DpdkDevice::startCaptureSingleThread()</a></li>
</ul>
<p><b>Sending packets:</b> <a class="el" href="a00014.html">DpdkDevice</a> has various methods for sending packets. They enable sending raw packets, parsed packets, etc. for all opened TX queues. See <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">DpdkDevice::sendPackets()</a><br />
</p>
<p><b>Get interface info</b>: <a class="el" href="a00014.html">DpdkDevice</a> provides all kind of information on the interface/device such as MAC address, MTU, link status, PCI address, PMD (poll-mode-driver) used for this port, etc. In addition it provides RX/TX statistics when receiving or sending packets<br />
</p>
<p><b>Known limitations:</b></p><ul>
<li>BPF filters are currently not supported by this device (as opposed to other PcapPlusPlus device types. This means that the device cannot filter packets before they get to the user</li>
<li>It's not possible to set or change NIC load-balancing method. DPDK provides this capability but it's still not supported by <a class="el" href="a00014.html">DpdkDevice</a> </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab772ecb6a13f970a1671a143dfcf8edc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the <a class="el" href="a00014.html">DpdkDevice</a>. When device is closed it's not possible work with it </p>

<p>Implements <a class="el" href="a00057.html#a5ce8877d4e047f11a3cb8d0f4f527e56">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a745ba46c5fbc633281c211e81cd4fea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getAmountOfFreeMbufs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of free mbufs in device's mbufs pool </dd></dl>

</div>
</div>
<a class="anchor" id="a24310ff4334d0defd3e46f144f7d987c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getAmountOfMbufsInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of mbufs currently in use in device's mbufs pool </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3e4e76fde88ccd4afe897bbf22c0b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pcpp::DpdkDevice::getCurrentCoreId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The core ID used in this context </dd></dl>

</div>
</div>
<a class="anchor" id="a28379431cb808e54444d17e692e10cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::getDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device ID (DPDK port ID) </dd></dl>

</div>
</div>
<a class="anchor" id="a8b61a3bc39b4076528390401615340b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::DpdkDevice::getDeviceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device name which is in the format of 'DPDK_[PORT-ID]' </dd></dl>

</div>
</div>
<a class="anchor" id="a4ca58304c0df036a23e40f1505925319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::getLinkStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00067.html">LinkStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>linkStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the link status (link up/down, link speed and link duplex) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linkStatus</td><td>A reference to object the result shall be written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a6e40aef3710aca2fbf3b99fcab5029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">MacAddress</a> pcpp::DpdkDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The MAC address of the device (DPDK port) </dd></dl>

</div>
</div>
<a class="anchor" id="ab4148c223d9f267c21b8ce30fe20310d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's maximum transmission unit (MTU) in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a9b9590ae9b2dd5ed3f978a602a3eadd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getNumOfOpenedRxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of RX queues currently opened for this device (as configured in <a class="el" href="a00014.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> ) </dd></dl>

</div>
</div>
<a class="anchor" id="aab80b01d6068166d7fd0d4d5325e0630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getNumOfOpenedTxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of TX queues currently opened for this device (as configured in <a class="el" href="a00014.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> ) </dd></dl>

</div>
</div>
<a class="anchor" id="aed02181d03db521d72771a4b355bad63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00089.html">PciAddress</a> pcpp::DpdkDevice::getPciAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The PCI address of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6fe0ee2bff8d8aab767e8fd2fb7936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string pcpp::DpdkDevice::getPMDName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the PMD (poll mode driver) DPDK is using for this device. You can read about PMDs in the DPDK documentation: <a href="http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html">http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af783ec3a927bcdf098f604ffde385a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00197.html#adb43f1f8284d4e0b74d1c77b70152fa9">DpdkPMDType</a> pcpp::DpdkDevice::getPMDType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The enum type of the PMD (poll mode driver) DPDK is using for this device. You can read about PMDs in the DPDK documentation: <a href="http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html">http://dpdk.org/doc/guides/prog_guide/poll_mode_drv.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a385533189ae3c86b503996d03b5e0d84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve RX packet statistics from device </p><dl class="todo"><dt><b><a class="el" href="a00199.html#_todo000001">Todo:</a></b></dt><dd>pcap_stat is a poor struct that doesn't contain all the information DPDK can provide. Consider using a more extensive struct </dd></dl>

<p>Implements <a class="el" href="a00057.html#ace3640f2330899687e34aa3789f4cd05">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae7d6c3b4cba6b5eb427c6d2ac6ed7537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getTotalNumOfRxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of RX queues available on this device </dd></dl>

</div>
</div>
<a class="anchor" id="a23cba8587e0770602c79f146bd98bb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pcpp::DpdkDevice::getTotalNumOfTxQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of TX queues available on this device </dd></dl>

</div>
</div>
<a class="anchor" id="ac6a4321f24373e785cc07950a2434527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::isVirtual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this device is a virtual interface (such as VMXNET3, 1G/10G virtual function, etc.), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad5717b8aa18dbb657e4c346adbb38163"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00057.html">IPcapDevice</a>. It calls <a class="el" href="a00014.html#afae6116f6d0d7f515acb1c327fdcebbb">openMultiQueues()</a> with 1 RX queue and 1 TX queue. Notice opening the device only makes it ready to use, it doesn't start packet capturing. The device is opened in promiscuous mode </p><dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false if device is already opened, if RX/TX queues configuration failed or of DPDK port configuration and startup failed </dd></dl>

<p>Implements <a class="el" href="a00057.html#aa7d1358756653febf63d23b21447649c">pcpp::IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="afae6116f6d0d7f515acb1c327fdcebbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::openMultiQueues </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numOfRxQueuesToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numOfTxQueuesToOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00015.html">DpdkDeviceConfiguration</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code><a class="el" href="a00015.html">DpdkDeviceConfiguration</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the DPDK device. Notice opening the device only makes it ready to use, it doesn't start packet capturing. This method initializes RX and TX queues, configures the DPDK port and starts it. Call <a class="el" href="a00014.html#ab772ecb6a13f970a1671a143dfcf8edc">close()</a> to close the device. The device is opened in promiscuous mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfRxQueuesToOpen</td><td>Number of RX queues to setup. This number must be smaller or equal to the return value of <a class="el" href="a00014.html#ae7d6c3b4cba6b5eb427c6d2ac6ed7537">getTotalNumOfRxQueues()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numOfTxQueuesToOpen</td><td>Number of TX queues to setup. This number must be smaller or equal to the return value of <a class="el" href="a00014.html#a23cba8587e0770602c79f146bd98bb3b">getTotalNumOfTxQueues()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Optional parameter for defining special port configuration parameters such as number of receive/transmit descriptors. If not set the default parameters will be set (see <a class="el" href="a00015.html">DpdkDeviceConfiguration</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false if device is already opened, if RX/TX queues configuration failed or of DPDK port configuration and startup failed </dd></dl>

</div>
</div>
<a class="anchor" id="a1459cfd1875c5033398a1ac7c00f3394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive raw packets from the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A vector where all received packets will be written into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packets were received and no error occurred or false if device isn't opened, if device is currently capturing (using <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> or <a class="el" href="a00014.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads()</a> ), if rxQueueId doesn't exist on device, or if DPDK receive packets method returned an error </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8dc9d0c67e4d5c1d55f4a32e2e7c6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00072.html">MBufRawPacket</a> **&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rawPacketArrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive raw packets from the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketsArr</td><td>A pointer to a non-allocated array of <a class="el" href="a00072.html">MBufRawPacket</a> pointers where all received packets will be written into. The array will be allocated by this method and its length will be written into rawPacketArrLength. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rawPacketArrLength</td><td>The length of <a class="el" href="a00072.html">MBufRawPacket</a> pointers array will be written into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packets were received and no error occurred or false if device isn't opened, if device is currently in capture mode (using <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> or <a class="el" href="a00014.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads()</a> ), if rxQueueId doesn't exist on device, or if DPDK receive packets method returned an error </dd></dl>

</div>
</div>
<a class="anchor" id="a4c9a34cc0c4144dbbfa567747ebedef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::receivePackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00078.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>packetsArrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxQueueId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive parsed packets from the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArr</td><td>A pointer to a non-allocated array of <a class="el" href="a00078.html">Packet</a> pointers where all received packets will be written into. The array will be allocated by this method and its length will be written into packetsArrLength. Notice it's the user responsibility to free the array and its content when done using it </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">packetsArrLength</td><td>The length of <a class="el" href="a00078.html">Packet</a> pointers array will be written into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxQueueId</td><td>The RX queue to receive packets from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packets were received and no error occurred or false if device isn't opened, if device is currently capturing (using <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> or <a class="el" href="a00014.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads()</a> ), if rxQueueId doesn't exist on device, or if DPDK receive packets method returned an error </dd></dl>

</div>
</div>
<a class="anchor" id="a80b57e22a8ecf001ea2ca9dbd023d277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send packet raw data to the network. For the send packets algorithm see <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets()</a>, but keep in mind this method sends only 1 packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The packet raw data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>The length of the raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent to. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened or the sending algorithm failed (for example: couldn't allocate an mbuf or DPDK returned an error) </dd></dl>

</div>
</div>
<a class="anchor" id="aced19469d7bb32b147d1a7aadbe4aa37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">RawPacket</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a raw packet to the network. For the send packets algorithm see <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets()</a>, but keep in mind this method sends only 1 packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>The raw packet to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent to. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened or the sending algorithm failed (for example: couldn't allocate an mbuf or DPDK returned an error) </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed37d14a7ef70e31fd88510d49ca9c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00078.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a parsed packet to the network. For the send packets algorithm see <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets()</a>, but keep in mind this method sends only 1 packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>The parsed packet to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packet will be sent on. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully or false if device is not opened, TX queue isn't opened or the sending algorithm failed (for example: couldn't allocate an mbuf or DPDK returned an error) </dd></dl>

</div>
</div>
<a class="anchor" id="a09e69fcb1444764603d3238b53bb0b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an array of raw packets to the network.<br />
<br />
 The sending algorithm works as follows: the algorithm tries to allocate a group of mbufs from the device mbuf pool. For each mbuf allocated a raw packet data is copied to the mbuf. This means that the packets sent as input to this method aren't affected (aren't freed, changed, or anything like that). The algorithm will continue allocating mbufs until: no more raw packets to send; OR cannot allocate mbufs because mbug pool is empty; OR number of allocated mbufs is higher than a threshold of 80% of total TX descriptors. When one of these happen the algorithm will try to send the mbufs it already got through DPDK API. DPDK will free these mbufs after sending them. Then the algorithm will try to allocate mbufs again and send them again until no more raw packets are left to send to send or mbuf allocation failed 3 times in a raw. Raw packets that are bigger than the size of an mbuf or with length 0 will be skipped. Same goes for raw packets whose data could not be copied to the allocated mbuf for some reason. An appropriate error will be printed for each such packet </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>A pointer to an array of raw packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets successfully sent. If device is not opened or TX queue isn't open, 0 will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="a9fab081e84cefcbbe7980f1a294aa81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00078.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an array of parsed packets to the network. For the send packets algorithm see <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>A pointer to an array of parsed packet pointers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets successfully sent. If device is not opened or TX queue isn't open, 0 will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="ad779de9154a16454e2075441a4046251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::DpdkDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPacketsVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txQueueId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a vector of raw packets to the network. For the send packets algorithm see <a class="el" href="a00014.html#a09e69fcb1444764603d3238b53bb0b8d">sendPackets()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsVec</td><td>The vector of raw packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txQueueId</td><td>An optional parameter which indicates to which TX queue the packets will be sent to. The default is TX queue 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets successfully sent. If device is not opened or TX queue isn't open, 0 will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="a76b3bf26f2e77126c6ebc443600316e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00021.html">GeneralFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00057.html">IPcapDevice</a>. <b>BPF filters are currently not implemented for <a class="el" href="a00014.html">DpdkDevice</a></b> </p><dl class="section return"><dt>Returns</dt><dd>Always false with a "Filters aren't supported in DPDK device" error message </dd></dl>

</div>
</div>
<a class="anchor" id="a0145dc440ebcd7c0a05709c57c2fa99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filterAsString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden method from <a class="el" href="a00057.html">IPcapDevice</a>. <b>BPF filters are currently not implemented for <a class="el" href="a00014.html">DpdkDevice</a></b> </p><dl class="section return"><dt>Returns</dt><dd>Always false with a "Filters aren't supported in DPDK device" error message </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3ab407d91e32668c844ed36b64fea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::setMtu </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newMtu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new maximum transmission unit (MTU) for this device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newMtu</td><td>The new MTU in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if MTU was set successfully, false if operation failed or if PMD doesn't support changing the MTU </dd></dl>

</div>
</div>
<a class="anchor" id="a092dcc89b546b902698842fade374376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::startCaptureMultiThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreMask&#160;</td>
          <td class="paramname"><em>coreMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method does exactly what <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> does, but with more than one RX queue / capturing thread. It's called with a core mask as a parameter and creates a packet capture thread on every core. Each capturing thread is assigned with a specific RX queue. This method assumes all cores in the core-mask are available and there are enough opened RX queues to match for each thread. If these assumptions are not true an error is returned. After invoking all threads, all of them run in an endless loop and try to capture packets from their designated RX queues. Each time a burst of packets is captured the callback is invoked with the user cookie and the thread ID that captured the packets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>The user callback which will be invoked each time a burst of packets is captured by the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>The user callback is invoked with this cookie as a parameter. It can be used to pass information from the user application to the callback </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">coreMask</td><td>The core-mask for creating the cpature threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all capture threads started successfully or false if device is already in capture mode, not all cores in the core-mask are available to DPDK, there are not enough opened RX queues to match all cores in the core-mask, or if thread invocation failed. In all of these cases an appropriate error message will be printed </dd></dl>

</div>
</div>
<a class="anchor" id="ae200ae83e4eb63c66ff18a1004836f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::DpdkDevice::startCaptureSingleThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#aebc46b2f805a197cd4b79316a9237c26">OnDpdkPacketsArriveCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketsArrive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketsArriveUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There are two ways to capture packets using <a class="el" href="a00014.html">DpdkDevice</a>: one of them is using worker threads (see <a class="el" href="a00016.html#a6a2d2fdf700451adb9a27567f6e6eda3">DpdkDeviceList::startDpdkWorkerThreads()</a> ) and the other way is setting a callback which is invoked each time a burst of packets is captured. This method implements the second way. After invoking this method the <a class="el" href="a00014.html">DpdkDevice</a> enters capture mode and starts capturing packets. This method assumes there is only 1 RX queue opened for this device, otherwise an error is returned. It then allocates a core and creates 1 thread that runs in an endless loop and tries to capture packets using DPDK. Each time a burst of packets is captured the user callback is invoked with the user cookie as a parameter. This loop continues until <a class="el" href="a00014.html#ae3238998a22eb354c388d68d92285de7">stopCapture()</a> is called. Notice: since the callback is invoked for every packet burst using this method can be slower than using worker threads. On the other hand, it's a simpler way comparing to worker threads </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArrive</td><td>The user callback which will be invoked each time a packet burst is captured by the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketsArriveUserCookie</td><td>The user callback is invoked with this cookie as a parameter. It can be used to pass information from the user application to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture thread started successfully or false if device is already in capture mode, number of opened RX queues isn't equal to 1, if the method couldn't find an available core to allocate for the capture thread, or if thread invocation failed. In all of these cases an appropriate error message will be printed </dd></dl>

</div>
</div>
<a class="anchor" id="ae3238998a22eb354c388d68d92285de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcpp::DpdkDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If device is in capture mode started by invoking <a class="el" href="a00014.html#ae200ae83e4eb63c66ff18a1004836f3d">startCaptureSingleThread()</a> or <a class="el" href="a00014.html#a092dcc89b546b902698842fade374376">startCaptureMultiThreads()</a>, this method will stop all capturing threads and set the device to non-capturing mode </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00197.html">pcpp</a></li><li class="navelem"><a class="el" href="a00014.html">DpdkDevice</a></li>
    <li class="footer">Generated on Sat Dec 10 2016 23:11:03 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
