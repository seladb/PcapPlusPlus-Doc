<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PcapPlusPlus: pcpp::WinPcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01535.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a01532.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcpp::WinPcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00170_source.html">WinPcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcpp::WinPcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a01535.png" usemap="#pcpp::WinPcapLiveDevice_map" alt=""/>
  <map id="pcpp::WinPcapLiveDevice_map" name="pcpp::WinPcapLiveDevice_map">
<area href="a01235.html" alt="pcpp::PcapLiveDevice" shape="rect" coords="0,56,160,80"/>
<area href="a01127.html" alt="pcpp::IPcapDevice" shape="rect" coords="0,0,160,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc1fc2d75dc09c9e3920c6c1d3f0ce37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#acc1fc2d75dc09c9e3920c6c1d3f0ce37">getDeviceType</a> ()</td></tr>
<tr class="separator:acc1fc2d75dc09c9e3920c6c1d3f0ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22e2966176d4127e69300cd4b208758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#af22e2966176d4127e69300cd4b208758">startCapture</a> (<a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUsrrCookie)</td></tr>
<tr class="separator:af22e2966176d4127e69300cd4b208758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70126c098779937e5ce88360966c7aa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#a70126c098779937e5ce88360966c7aa1">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a70126c098779937e5ce88360966c7aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74824694b8f72f687dec10557a196675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#a74824694b8f72f687dec10557a196675">startCapture</a> (<a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:a74824694b8f72f687dec10557a196675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f1d43beaf1e839959ec51838a246f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#a8f0f1d43beaf1e839959ec51838a246f">sendPackets</a> (<a class="el" href="a01291.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:a8f0f1d43beaf1e839959ec51838a246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff78da9d57c6ec9046de32746943bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#aebff78da9d57c6ec9046de32746943bd">setMinAmountOfDataToCopyFromKernelToApplication</a> (int size)</td></tr>
<tr class="separator:aebff78da9d57c6ec9046de32746943bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfdf0d5b3e54235756d9695b90f3ef7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01535.html#a8dfdf0d5b3e54235756d9695b90f3ef7">getMinAmountOfDataToCopyFromKernelToApplication</a> ()</td></tr>
<tr class="separator:a8dfdf0d5b3e54235756d9695b90f3ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a01235"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a01235')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a01235.html">pcpp::PcapLiveDevice</a></td></tr>
<tr class="memitem:a0172bbe45fb66f4722bf2bd4847c91fe inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a0172bbe45fb66f4722bf2bd4847c91fe">~PcapLiveDevice</a> ()</td></tr>
<tr class="separator:a0172bbe45fb66f4722bf2bd4847c91fe inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d887cb3005e75cc67609b957a886c inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a606d887cb3005e75cc67609b957a886c">getName</a> ()</td></tr>
<tr class="separator:a606d887cb3005e75cc67609b957a886c inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdd1317bb1387a067bfd21d49e5b059 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#aacdd1317bb1387a067bfd21d49e5b059">getDesc</a> ()</td></tr>
<tr class="separator:aacdd1317bb1387a067bfd21d49e5b059 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75748fd040d8f97f4c43b1524e4fb479 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a75748fd040d8f97f4c43b1524e4fb479">getLoopback</a> ()</td></tr>
<tr class="separator:a75748fd040d8f97f4c43b1524e4fb479 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c3eb2f9d1af368fa0d9da30ef60f9b inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ae9c3eb2f9d1af368fa0d9da30ef60f9b">getMtu</a> ()</td></tr>
<tr class="separator:ae9c3eb2f9d1af368fa0d9da30ef60f9b inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a1a299d54e2150eedf96f90ad5caa inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pcap_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a5a9a1a299d54e2150eedf96f90ad5caa">getAddresses</a> ()</td></tr>
<tr class="separator:a5a9a1a299d54e2150eedf96f90ad5caa inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfa0fc4bc0374aaf9f11333a9904110 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a01095.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a1bfa0fc4bc0374aaf9f11333a9904110">getMacAddress</a> ()</td></tr>
<tr class="separator:a1bfa0fc4bc0374aaf9f11333a9904110 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb6a59e454d6594451e4b285344181 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00967.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a36fb6a59e454d6594451e4b285344181">getIPv4Address</a> ()</td></tr>
<tr class="separator:a36fb6a59e454d6594451e4b285344181 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df16cfa57eea8f275d8ddfecfee968 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00967.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ab7df16cfa57eea8f275d8ddfecfee968">getDefaultGateway</a> ()</td></tr>
<tr class="separator:ab7df16cfa57eea8f275d8ddfecfee968 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cdf86d684d71cf556cd9dd98f1a9c6 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00967.html">IPv4Address</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a89cdf86d684d71cf556cd9dd98f1a9c6">getDnsServers</a> ()</td></tr>
<tr class="separator:a89cdf86d684d71cf556cd9dd98f1a9c6 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b001c38b0f1e43a1691fedbd1b0cc inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a349b001c38b0f1e43a1691fedbd1b0cc">startCapture</a> (<a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:a349b001c38b0f1e43a1691fedbd1b0cc inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479987f8faf52328061e18af2addcc5 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ae479987f8faf52328061e18af2addcc5">startCaptureBlockingMode</a> (<a class="el" href="a00179.html#a1fb7ed19d0cb6b09ab2b1d0570b64cb4">OnPacketArrivesStopBlocking</a> onPacketArrives, void *userCookie, int timeout)</td></tr>
<tr class="separator:ae479987f8faf52328061e18af2addcc5 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818da3e11e0c953385badf6233ee0f43 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture</a> ()</td></tr>
<tr class="separator:a818da3e11e0c953385badf6233ee0f43 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7b9be7551ad7759c32e9d5fbabd5c8 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2e7b9be7551ad7759c32e9d5fbabd5c8">sendPacket</a> (<a class="el" href="a01291.html">RawPacket</a> const &amp;rawPacket)</td></tr>
<tr class="separator:a2e7b9be7551ad7759c32e9d5fbabd5c8 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f45c8bc2c370f3f2120909f36b22802 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2f45c8bc2c370f3f2120909f36b22802">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:a2f45c8bc2c370f3f2120909f36b22802 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa547d006ea10328c631eb5379798dede inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#aa547d006ea10328c631eb5379798dede">sendPacket</a> (<a class="el" href="a01115.html">Packet</a> *packet)</td></tr>
<tr class="separator:aa547d006ea10328c631eb5379798dede inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9efc27c7c0778d47c94dac02defa22b inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#af9efc27c7c0778d47c94dac02defa22b">sendPackets</a> (<a class="el" href="a01115.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:af9efc27c7c0778d47c94dac02defa22b inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb039496514f3c53bc7eca2235653c70 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#adb039496514f3c53bc7eca2235653c70">sendPackets</a> (const <a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:adb039496514f3c53bc7eca2235653c70 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281f2cd6062791c68ecdd82384f751f8 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open</a> ()</td></tr>
<tr class="separator:a281f2cd6062791c68ecdd82384f751f8 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccb5eac1b23651e7b157b628435528 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#ad7ccb5eac1b23651e7b157b628435528">close</a> ()</td></tr>
<tr class="separator:ad7ccb5eac1b23651e7b157b628435528 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f87416b25abe3b625f0f9993bb7e1b inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a68f87416b25abe3b625f0f9993bb7e1b">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a68f87416b25abe3b625f0f9993bb7e1b inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e61feb22fdab2bbbff8da63751169c9 inherit pub_methods_a01235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a5e61feb22fdab2bbbff8da63751169c9">open</a> (<a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> mode)</td></tr>
<tr class="separator:a5e61feb22fdab2bbbff8da63751169c9 inherit pub_methods_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a01127"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a01127')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a01127.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a22b03cdabb9f359c6bed0728c3614789">isOpened</a> ()</td></tr>
<tr class="separator:a22b03cdabb9f359c6bed0728c3614789 inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#aadba6a20265dca6ba29b548325a798fe">setFilter</a> (<a class="el" href="a01159.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:aadba6a20265dca6ba29b548325a798fe inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a134f061d7883abbdb256abd48d53e66c">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a134f061d7883abbdb256abd48d53e66c inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a01127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#aba28d535c6aa05e9f9492c82ece25de7">clearFilter</a> ()</td></tr>
<tr class="separator:aba28d535c6aa05e9f9492c82ece25de7 inherit pub_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_a01235"><td colspan="2" onclick="javascript:toggleInherit('pub_types_a01235')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="a01235.html">pcpp::PcapLiveDevice</a></td></tr>
<tr class="memitem:a0e343585711ee4e02d4b9507467135ab inherit pub_types_a01235"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> { <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba975b2663c8a8bcc495a71af5e80f8652">LibPcapDevice</a>, 
<a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba0c8c0011ab41d3aeee8e8f1c29fd07b6">WinPcapDevice</a>, 
<a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135aba47692cc2f098676c70ad0505059f581c">RemoteDevice</a>
 }</td></tr>
<tr class="separator:a0e343585711ee4e02d4b9507467135ab inherit pub_types_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381e7f053285090f0f9620bcbd8f0f3 inherit pub_types_a01235"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3">DeviceMode</a> { <a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3ad57df3ce2415ba6f804539bb268aecdf">Normal</a> = 0, 
<a class="el" href="a01235.html#a2381e7f053285090f0f9620bcbd8f0f3af1c5bb543295a735a99cc9f88ac67bca">Promiscuous</a> = 1
 }</td></tr>
<tr class="separator:a2381e7f053285090f0f9620bcbd8f0f3 inherit pub_types_a01235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_a01127"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a01127')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a01127.html">pcpp::IPcapDevice</a></td></tr>
<tr class="memitem:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a01127"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a5cc546829570cd981bfa762acd9759c8">verifyFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cc546829570cd981bfa762acd9759c8 inherit pub_static_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a01127"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html#a54df47e98feadfd830789ca3a7f5f86b">matchPakcetWithFilter</a> (std::string filterAsString, <a class="el" href="a01291.html">RawPacket</a> *rawPacket)</td></tr>
<tr class="separator:a54df47e98feadfd830789ca3a7f5f86b inherit pub_static_methods_a01127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a Windows network interface (each of the interfaces listed in ipconfig). This class is almost similar in its capabilities to <a class="el" href="a01235.html">PcapLiveDevice</a> (its parent class) with some small changes that mainly result from differences between libpcap and WinPcap. Please see the reference for <a class="el" href="a01235.html">PcapLiveDevice</a> for more details </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acc1fc2d75dc09c9e3920c6c1d3f0ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1fc2d75dc09c9e3920c6c1d3f0ce37">&#9670;&nbsp;</a></span>getDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a01235.html#a0e343585711ee4e02d4b9507467135ab">LiveDeviceType</a> pcpp::WinPcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap or a remote device) </dd></dl>

<p>Reimplemented from <a class="el" href="a01235.html#a70b3e39208905585907c3557971b71e8">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a8dfdf0d5b3e54235756d9695b90f3ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfdf0d5b3e54235756d9695b90f3ef7">&#9670;&nbsp;</a></span>getMinAmountOfDataToCopyFromKernelToApplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pcpp::WinPcapLiveDevice::getMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current amount of data in the kernel buffer that causes a read from the application to return (see also <a class="el" href="a01535.html#aebff78da9d57c6ec9046de32746943bd">setMinAmountOfDataToCopyFromKernelToApplication()</a>) </dd></dl>

</div>
</div>
<a id="a8f0f1d43beaf1e839959ec51838a246f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0f1d43beaf1e839959ec51838a246f">&#9670;&nbsp;</a></span>sendPackets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pcpp::WinPcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01291.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="a01291.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The array of <a class="el" href="a01291.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is 0</li>
<li><a class="el" href="a01115.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a01115.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a01235.html#acf8df597d7d931fce5d006f20c9fbce3">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="aebff78da9d57c6ec9046de32746943bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebff78da9d57c6ec9046de32746943bd">&#9670;&nbsp;</a></span>setMinAmountOfDataToCopyFromKernelToApplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::setMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WinPcap has an ability (that doesn't exist in libpcap) to change the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires). Please see documentation for pcap_setmintocopy for more info. This method enables the user to change this size. Note the device must be open for this method to work </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size to set in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if set succeeded, false if the device is closed or if pcap_setmintocopy failed </dd></dl>

</div>
</div>
<a id="af22e2966176d4127e69300cd4b208758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22e2966176d4127e69300cd4b208758">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#aa07524ba3fd4932968d2c302a936ae10">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a01235.html#a78306fe44879e457df4043a117f6863a">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a70126c098779937e5ce88360966c7aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70126c098779937e5ce88360966c7aa1">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00179.html#af797dbce1a97d45a6b86cdedb6d627da">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a01235.html#a2933139d284d7c167283982ec8b56559">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
<a id="a74824694b8f72f687dec10557a196675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74824694b8f72f687dec10557a196675">&#9670;&nbsp;</a></span>startCapture() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcpp::WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00179.html#a4c0775fb93a0867d2afa7992d55957f0">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="a01291.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a01235.html#a818da3e11e0c953385badf6233ee0f43">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a01235.html#a281f2cd6062791c68ecdd82384f751f8">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="a01291.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a01235.html#a821bbac1ffad5a75c6a0be1ff362eb9f">pcpp::PcapLiveDevice</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00179.html">pcpp</a></li><li class="navelem"><a class="el" href="a01535.html">WinPcapLiveDevice</a></li>
    <li class="footer">Generated on Sat Aug 4 2018 23:35:14 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
